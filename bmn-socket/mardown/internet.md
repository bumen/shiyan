### 计算机网络
 * 分类
   1. 计算机
   2. 网络操作系统
     + TCP/IP模型
   3. 传输介质
   4. 相应软件
   
 * 过程
   1. [ ] tcp协议栈 
     1. [x] 以太网
     2. [ ] ip
     3. [ ] tcp 
     4. [ ] udp 
     
   2. [x] DNS
   3. [x] arp
   4. [x] 消息发送
     1. [x] ip地址，子网
     2. [x] 内网发送
     3. [x] 路由器
     4. [x] 外网发送
   5. [x] 传输介质
   6. [x] IDC
   
### ip分类
 * 一共大约2^32=43亿个ip。现在已经分发完毕 
 * 分网络部分+主机部分
 * a
   + 网络部分占一个字节
   + 0, ip/8
   + 1-126
   + 最大网络数：2^7-2  = 126个
   + 最大主机数：2^24-2 = 16,777,241 = 1千6百多万
   + 私有ip段：10.0.0.0-10.255.255.255
   
 * b
   + 网络部分占二个字节
   + 10, ip/16
   + 128-191
   + 最大网络数：2^14 -1 = 191,255 = 19万
   + 最大主机数：2^16 -2 = 65534= 6万
   + 私有ip段：172.16.0.0-172.31.255.255
   
 * c
   + 网络部分占三个字节
   + 110， ip/24
   + 192-223
   + 最大网络数：2^21 -1 = 223,255,255 = 2亿2千万多个 
   + 最大主机数：2^8 - 2 = 254个
   + 私有ip段：192.168.0.0-192.168.255.255

 * d
   + 不区别网络与主机
   + 多播地址
   + 1110, ip/4
   + 224-239
 * e
   + 不区别网络与主机
   + 保留使用
   + 1111, ip/4
   + 240-255
   
 * 直接广播地址：
   + 网络地址+主机地址变成全为1。 
   + 如：ip地址192.168.100.5, 子网掩码为:255.255.255.0 表示一个c类ip
     - 网络地址为：192.168.100.0, 则主机全为1之后变成广播地址：192.168.100.255
     - 所以最大主机数 2^8 - 2, 去掉全0,全1情况
      > 主机不包括网络地址和广播地址：全0为网络地址，全1为广播地址
     
   +  地址范围就是含在本网段内的所有主机
     - 网络地址+1  至  广播地址-1 
     
   
 * 有限广播地址: 255.255.255.255
   + 是当前子网的广播地址
   + 在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出现在本地网络中
 * 0.0.0.0
   + 对应当前主机
 * IP地址不能以127为开头
   + 该类地址中数字127.0.0.1~127.255.255.254用于回路测试


### ip分发
 * 全球IP地址块被IANA(Internet Assigned Numbers Authority)分配给全球三大地区性IP地址分配机构
   1. ARIN(American Registry for Internet Numbers)
     + 负责北美、南美、加勒比以及非洲撒哈啦部分的IP地址分配。同时还要给全球NSP(Network Service Providers)分配地址。
   2. RIPE(Reseaux IP Europeens)
     + 负责欧洲、中东、北非、西亚部分地区(前苏联)
   3. APNIC(Asia Pacific Network Information Center)
     + 负责亚洲、太平洋地区
       
 * APNIC IP地址分配信息总表的获取
   + APNIC提供了每日更新的亚太地区IPv4，IPv6，AS号分配的信息表  
   `http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest`  
   + 该文件的格式与具体内容参见  
    `ftp://ftp.apnic.net/pub/apnic/stats/apnic/README.TXT`
    
   > 获得这些地址之后可以在OpenWrt上配合shadowsocks翻墙 ^_^
   
   
### 网络
 * 只有在一个网络号下的计算机之间才能"直接"互通，不同网络号的计算机要通过网关（Gateway）才能互通

### IP子网划分
 * IP网络还允许划分成更小的网络，称为子网（Subnet）
 * 子网掩码的作用就是用来判断任意两个IP地址是否属于同一子网络，这时只有在同一子网的计算机才能"直接"互通
 * IP地址分网络号和主机号，要将一个网络划分为多个子网，因此网络号将要占用原来的主机位
   + 对于一个C类地址，它用21位来标识网络号，要将其划分为2个子网则需要占用1位原来的主机标识位，此时网络号位变为22位为主机标示变为7位
   + 同理借用2个主机位则可以将一个C类网络划分为4个子网
   + 那计算机是怎样才知道这一网络是否划分了子网呢
     - 这就可以从子网掩码中看出
   + 子网掩码和IP地址一样有32bit，确定子网掩码的方法是其与IP地址中标识网络号的所有对应位都用"1"，而与主机号对应的位都是"0"
   + 如分为2个子网的C类IP地址用22位来标识网络号，则其子网掩码为：11111111 11111111 11111111 10000000即255.255.255.128。
   
 * 标准子网掩码
   + a类：255.0.0.0
   + b类：255.255.0.0
   + c类：255.255.255.0
   
 * 特殊的子网掩码，即划分了子网的。
   + 这里拿c类ip为例
       ``` 
       子网位数 子网掩码      主机数 可用主机数  子网个数
       
       1      255.255.255.128  128   126      2
       
       2      255.255.255.192  64    62       4
       
       3      255.255.255.224  32    30       8
       
       4      255.255.255.240  16    14      16
       
       5      255.255.255.248  8     6       32
       
       6      255.255.255.252   4     2      64
       ```  
       
 * 不同子网通信也需要路由器，因为不在同一网络中
 
### 消息发送
 * 消息发送
   + 子网内：查本地路由发现是子网内通信不需要路由器直接发送到对方
   + 子网外：查本地路由发现不是相同子网内通信，需要先发给网关，网关往路由往下一地跳发
   > 总是每次发送前都需要先走路由过程（即网络号判断），然后确定怎么发
   
### 消息类型
 * TCP传给IP的数据单元称作TCP报文段或简称为TCP段（TCP segment）
 * IP传给网络接口层的数据单元称作IP数据报(IP datagram)
 * 通过以太网传输的比特流称作帧(Frame)。
   
   
### 路由器
 * 静态路由表
   + 管理员手动设置
 * 动态路由表
   + 生成：向网络广播分组数据包，收到消息的路由器会同步路由表
 * 作用
   + 消息转发
   
### 传输介质
 * IDC(Internet Data Center) 数据中心可以叫机房
   - 同时可以接入多个ISP
 * 国家骨干
 * 省骨干
 * 城域网
 * PON: Passive Optical Network 无源光网络
   + PON是非对称，点到多点(P2MP)结构
   + OLT: 光线路终端 Optical Line Terminal
     - 一个区域，如：社区
     - 相当于master角色
     
   + POS: Passive Optical Splitter 无源分光器
   + ODF/交换箱: 
     - 马路边上的
   + DNT/DNU
     - 负责一个单元楼分发
     - 相当于Slave角色
   
   ``` 
     -- PON组成
     
            OLT
             |
          _ POS _
        /    |    \
       ONU  ONU   DNT
   ```  
   
 * 路由器

### DNS Domain Name System 域名系统
 * 互联网上作为域名和IP地址相互映射的一个分布式数据库
 * 两种解析过程
   + 跟据本地DNS服务器配置
   1. 递归
     - 客户端->本地DNS->根域->1级域->2级域（已查到）
            <-      <-    <-    <-
            
   2. 迭代。一般应该是这种模式
     - 客户端->本地DNS(不知道返回根域)
     - 客户端->根域（不知道返回1极域）
     - 客户端->1级域（不知道返回2级域）
     - 客户端->2级域（已查到）
     
 * 客户端本地也经缓存DNS
   1. http 请求时会先检查本地hosts，如果有完成解析
   2. 如果没有，则查找本地DNS，如果有完成解析
   3. 如果没有，则根据本地DNS服务器的设置，采用递归或迭代查找
   

### arp
 * Address Resolution Protocol 地址解析协议
 * 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。
 * 扩展
   + 代理ARP"、"免费ARP"、"翻转ARP"、"逆向ARP
   
 * ARP缓存表
   + 在真正进行通信之前，通过arp请求获取映射后，存表里面放置了IP和MAC地址的映射信息
   + 并且如果电脑或者通信设备重启的话，这张表就会清空
   + 命令行"arp -a"查看具体信息


### NAT
 * Network Address Translation 网络地址转换
 * 允许一个整体机构以一个公用IP（Internet Protocol）地址出现在Internet上
   + 实现私有ip通过公有ip上网能力
   + 它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术。
   + 如果内网主机发出的请求包未经过NAT，那么当Web Server收到请求包，回复的响应包中的目的地址就是私网IP地址，在Internet上无法正确送达，导致连接失败
   
 * NAT有三种类型
   + 静态NAT(Static NAT)
   + 动态地址NAT(Pooled NAT)
   + 网络地址端口转换NAPT（Port-Level NAT）。Network Address Port Translation
   
 * NAPT 网络地址端口转换
   + 是把内部地址映射到外部网络的一个IP地址的不同端口上
   + 它可以将中小型的网络隐藏在一个合法的IP地址后面
   + 它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的端口号。
   + 它又包含两种转换方式
     - SNAT
     - DNAT
     
   + SNAT
     - Source NAT 源NAT
     - 修改数据包的源地址
     - 源NAT改变第一个数据包的来源地址，它永远会在数据包发送到网络之前完成，数据包伪装就是一具SNAT的例子。
     
   + DNAT 
     - Destination NAT 目的NAT
     - 修改数据包的目的地址
     - Destination NAT刚好与SNAT相反，它是改变第一个数据懈的目的地地址，如平衡负载、端口转发和透明代理就是属于DNAT。
     
 * NAT主要可以实现以下几个功能
   + 数据伪装
     - 可以将内网数据包中的地址信息更改成统一的对外地址信息，不让内网主机直接暴露在因特网上，保证内网主机的安全。同时，该功能也常用来实现共享上网。
     
   + 端口转发
     - 当内网主机对外提供服务时，由于使用的是内部私有IP地址，外网无法直接访问。因此，需要在网关上进行端口转发，将特定服务的数据包转发给内网主机。
     
   + 负载平衡
     - 目的地址转换NAT可以重定向一些服务器的连接到其他随机选定的服务器。
   + 失效终结
     - 目的地址转换NAT可以用来提供高可靠性的服务。如果一个系统有一台通过路由器访问的关键服务器，
     一旦路由器检测到该服务器当机，它可以使用目的地址转换NAT透明的把连接转移到一个备份服务器上
   + 透明代理
     - NAT可以把连接到因特网的HTTP连接重定向到一个指定的HTTP代理服务器以缓存数据和过滤请求
     - 一些因特网服务提供商就使用这种技术来减少带宽的使用而不用让他们的客户配置他们的浏览器支持代理连接。
     
     


### TCP协议

#### 三次握手
 * 第一次握手
   + 客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。
 * 第二次握手
   + 服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，
   随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。
 * 第三次握手
   + 客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，
   服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手建立连接，
   随后客户端与服务器端之间可以开始传输数据了。
 * 为什么3次握手
   + 前两次的握手很显然是必须的，主要是最后一次，即客户端收到服务端发来的确认后为什么还要向服务端再发送一次确认呢？
   这主要是为了防止已失效的请求报文段突然又传送到了服务端而产生连接的误判。
   ``` 
    考虑如下的情况：
    客户端发送了一个连接请求报文段到服务端，但是在某些网络节点上长时间滞留了，
    所以客户端又超时重发了一个连接请求报文段该服务端，而后正常建立连接，数据传输完毕，并释放了连接。
    如果这时候第一次发送的请求报文段（已过期的）延迟了一段时间后，又到了服务端，
    很显然，这本是一个早已失效的报文段，但是服务端收到后会误以为客户端又发出了一次连接请求，
    于是向客户端发出确认报文段，并同意建立连接。假设不采用三次握手，这时服务端只要发送了确认，新的连接就建立了。
    但由于客户端现阶段没有发出建立连接的请求，因此不会理会服务端的确认，也不会向服务端发送数据，而服务端却认为新的连接已经建立了，
    并在一直等待客户端发送数据，这样服务端就会一直等待下去，直到超出保活计数器的设定值，而将客户端判定为出了问题，
    才会关闭这个连接。这样就浪费了很多服务器的资源。而如果采用三次握手，客户端没有再向服务端发出确认，服务端由于收不到确认，
    就知道客户端没有要求建立连接，从而不建立该连接。
   ```

#### 四次挥手
 * TCP连接是全双工的，因此，每个方向都必须要单独进行关闭
 * 第一次挥手
   + 客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态
   + 意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。
 * 第二次挥手
   + 服务器端收到FIN后，先发送ack=M+1，告诉客户端，“你的请求我收到了，但是我还没准备好，请继续你等我的消息。
   + 这个时候客户端就进入FIN_WAIT_2状态，继续等待服务器端的FIN报文。
   
 * 第三次挥手
   + 当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。
 * 第四次挥手
   + 客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ACK=1，ack=N+1后进入TIME_WAIT状态，如果服务器端没有收到ACK则可以重传
   + 服务器端收到ACK后，就知道可以断开连接了（CLOSED状态）
   + 客户端等待了2MSL（时间MSL叫做最长报文寿命，RFC建议设为2分钟）后依然没有收到回复，则证明服务器端已正常关闭，客户端也可以关闭连接了。最终完成了四次握手。

 * 为什么4次挥手
 * 为什么客户端TIME_WAIT等待2MSL
   + 为了保证客户端发送的最后一个ACK报文段能够到达服务器
     - 该ACK报文段很有可能丢失，因而使处于在LIST—ACK状态的服务器收不到对已发送的FIN+ACK报文段的确认，
     服务器可能会重传这个FIN+ACK报文段，而客户端就在这2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，
     重新启动2MSL计时器，最后客户端和服务器都进入CLOSED状态。
   + 防止已失效的请求连接出现在本连接中
     - MSL是任何IP数据报能够在因特网中存活的最长时间
     - 在连接处于2MSL等待时，任何迟到的报文段将被丢弃，因为处于2MSL等待的，由该插口（插口是IP和端口对的意思，socket）
     定义的连接在这段时间内将不能被再用，这样就可以使下一个新的连接中不会出现这种旧的连接之前延迟的报文段。



    
### 既然mac地址唯一，为什么还要有IP地址?
 * mac地址相当于身份证，记录个人信息。但是这个人是可以移动的和它所在位置没有关系。如：只知道一个人的身份证是不能找到这个人的。
 * ip表达的是当前机器在网络中的位置
 * mac地址通常不会变，但ip是可变的，尤其是移动设置
 * https://showme.codes/2018-05-17/understand-mac-ip/
   + mac + 交换机不能解决世界内机器之间查找，所以发明了ip地址有相关技术
 
### 既然能通过ip地址发送数据，为什么要有mac地址
 * 历史原因，早期没有网络层，只有物理与链路层两者通信只需要mac地址就可以
   + 集线器：最早使用，局域网内机器通信都使用集线器，通过广播方式相互通信，效率低
   + 交换机：工作在链表层，解析mac地址，局域网内机器通信通过交换机，每个端口连接一台机器，交换机有所有连接设置的mac与端口映射表
   相互通信时通过mac地址映射实现直接通信不需要广播
   + 路由器：工作在网络层，解析ip. 实现不同网络机器之通信
   
 * 这样设计好
   + 网络层是网络层转发
   + 链路层是链路层转发，两者互不影响
   + max只负责设备到设备间通信
   
### MAC地址
 * 以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。
 网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址
 * 以太网数据包必须知道接收方的MAC地址，然后才能发送。
 
 * Ethernet接口，即网卡接口
   + 如果A与B的相连接口是Ethernet 接口，他们之间的通信需要知道彼此的MAC地址。
   + 接收以太网帧后网口会判断Ethernet Frame 和自己的MAC地址，如果 mismatch 则拒收
     - 所以消息在路由转发时需要不断修改帧目的地址和源地址。需要先通过arp获取对方的mac地址
     
 
### 网络层的由来
 * 以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。
 * 但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一"包"，不仅效率低，而且局限在发送者所在的子网络。
 也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。
 * 互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的
 * 因此，必须找到一种方法, 能够区分哪些MAC地址属于同一个子网络，哪些不是
   + 如果是同一个子网络，就采用广播方式发送
   + 否则就采用"路由"方式发送
 * 这就导致了"网络层"的诞生
   + 它的作用是引进一套新的地址
   + 使得我们能够区分不同的计算机是否属于同一个子网络
   + 这套地址就叫做"网络地址"，简称"网址"。
