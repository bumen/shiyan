## TCP相关
 * 面向连接的、可靠的字节流服务
   + 面向连接：两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。
 * 可靠性
   + 应用数据被分割成TCP认为最适合发送的数据块,由TCP传递给IP的信息单位称为报文段或段
   + 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
   + 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒
   + TCP将保持它首部和数据的检验和
     - 如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。
   + 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。
   如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。
   + 既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据
   + TCP还能提供流量控制。
     - CP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。
     这将防止较快主机致使较慢主机的缓冲区溢出

### 单机最大TCP连接数

### 构造虚拟TCP请求连接客户端

### 构造虚拟TCP响应连接服务器

### linux文件句柄
 * 1G内存的机器上大约有10万个句柄左右
 
### 检测TCP连接是否有效

#### 轮询扫描法
 * Map<uid, last_packet_time>，当请求来时，实时更新map
 * 启动一个线程，轮询扫描这个map
 * 效率低

#### 多timer触发法
 * Map<uid, last_packet_time>,记录uid最近请求时间
 * 当请求来时，实时更新map, 同时对这个uid请求包启动一个timer，30s后触发
 * 30s后与map里时间，判断是否超时
 * 比较耗资源
 
#### 环形队列法
 * 用数组，组成的环
 * 30s就是 array[30] 大小的环。 每个位置是一个set队列
 * 启动一个timer，每一秒扫描一次，curIndex移动一次。
 * 使用一个map<uid, slot> 记录uid上次放的哪个位置
 * 当请求来时，请求上次slot. 从队列中删除uid
 * 将uid加入到curIndex所在的位置 
 
### 高效延时消息
 * 也使用环形队列法
 * 如果48小时后触发
   + 创建环形队列3600大小
   + 任务集合，Set<Task>
   + 一个timer每一个触发一次
   + Task需要两个参数
      - Cycle-num : 环形队列要走几圈，才会触发。因为一圈是1小时
      - function: 触发的任务
 * 问题
   + 如果关服，怎么处理
      - 创建任务时持久化到磁盘
   + Set多在合适
      - 可以调整, Cycle-num 与环形队列大小
 
### 状态转换
 * 主动连接方
   + SYN_SENT
   + ESTABLISHED， 当发送FIN后，进入FIN_WAIT_1
   + FIN_WAIT_1
      - FIN_WAIT_2，当收到被动方ACK后进入
      - CLOSING，当收到被动方方FIN，并发送ACK后进入
      - TIME_WAIT，当收到被方FIN+ACK后进入，当FIN_WAIT_2收到FIN后进入，当CLOSING收到ACK后进入
 * 被动连接方
   + SYN_RCVD
   + ESTABLISHED
   + CLOSE_WAIT，当收到FIN,并发送ACK后进入
   + LAST_ACK，当发送FIN,后进入
   + CLOSE，当收到ACK后进入
 
### 
### 问题
 * 大量CLOSE_WAIT
   + 由于程序错误，没有关闭出现异常的连接
   + 通过配置参数缩短超时时间
 
 * 大量LAST_ACK
   + 由于主动方ACK包丢失
     - 重发fin
   + 由于主动方CLOSE
     - 此时直接LAST_ACK重传超时，进入CLOSE
   + 由于主动方商品被其它连接占用
     - 此LAST_ACK会再发送FIN关闭，此时主动会返回RST.最后LAST_ACK进入CLOSE
 
 * 大量TIME_WAIT
   + 服务端尽量不要主动关闭
   + 通过配置缩短TIME_WAIT时间
 
 * 大量FIN_WAIT_2
   + 通过配置超时，时间
   
   
### SYN_RCVD DDos攻击

### ESTABLISHED
 * 客户端正常关闭连接
 * 客记端突然断电
 
###
 
### 断线重连
 * 会导致之前旧的socket连接未正常关闭，占用资源
 * 会重新建立一条连接
 
### MSS Max Segment Size
 * 最大报文段长度
 * 表示TCP传往另一端的最大块数据的长度
 * 当一个连接建立时，连接的双方都要通告各自的MSS
 * 如果一方不接收来自另一方的MSS值，则MSS就定为默认值536字节（这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报)。
 * 它能将MSS值设置为外出接口上的MTU长度减去固定的IP首部和TCP首部长度
 * 如果目的IP地址为“非本地的(nonlocal)”
   + MSS通常的默认值为536
 * MSS让主机限制另一端发送数据报的长度，加上主机也能控制它发送数据报的长度，这将使以较小MTU连接到一个网络上的主机避免分段。
 * 系统允许发送的数据长度小于另一端的MSS值