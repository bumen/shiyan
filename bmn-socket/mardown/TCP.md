## TCP相关
 * 面向连接的、可靠的字节流服务
   + 面向连接：两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。
 * 可靠性
   + 应用数据被分割成TCP认为最适合发送的数据块,由TCP传递给IP的信息单位称为报文段或段
   + 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
   + 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒
   + TCP将保持它首部和数据的检验和
     - 如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。
   + 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。
   如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。
   + 既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据
   + TCP还能提供流量控制。
     - CP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。
     这将防止较快主机致使较慢主机的缓冲区溢出

### 单机最大TCP连接数

### 构造虚拟TCP请求连接客户端

### 构造虚拟TCP响应连接服务器

### linux文件句柄
 * 1G内存的机器上大约有10万个句柄左右
 
### 检测TCP连接是否有效

#### 轮询扫描法
 * Map<uid, last_packet_time>，当请求来时，实时更新map
 * 启动一个线程，轮询扫描这个map
 * 效率低

#### 多timer触发法
 * Map<uid, last_packet_time>,记录uid最近请求时间
 * 当请求来时，实时更新map, 同时对这个uid请求包启动一个timer，30s后触发
 * 30s后与map里时间，判断是否超时
 * 比较耗资源
 
#### 环形队列法
 * 用数组，组成的环
 * 30s就是 array[30] 大小的环。 每个位置是一个set队列
 * 启动一个timer，每一秒扫描一次，curIndex移动一次。
 * 使用一个map<uid, slot> 记录uid上次放的哪个位置
 * 当请求来时，请求上次slot. 从队列中删除uid
 * 将uid加入到curIndex所在的位置 
 
### 高效延时消息
 * 也使用环形队列法
 * 如果48小时后触发
   + 创建环形队列3600大小
   + 任务集合，Set<Task>
   + 一个timer每一个触发一次
   + Task需要两个参数
      - Cycle-num : 环形队列要走几圈，才会触发。因为一圈是1小时
      - function: 触发的任务
 * 问题
   + 如果关服，怎么处理
      - 创建任务时持久化到磁盘
   + Set多在合适
      - 可以调整, Cycle-num 与环形队列大小
 
### 状态转换
 * 主动连接方
   + SYN_SENT
   + ESTABLISHED， 当发送FIN后，进入FIN_WAIT_1
   + FIN_WAIT_1
      - FIN_WAIT_2，当收到被动方ACK后进入
      - CLOSING，当收到被动方方FIN，并发送ACK后进入
      - TIME_WAIT，当收到被方FIN+ACK后进入，当FIN_WAIT_2收到FIN后进入，当CLOSING收到ACK后进入
 * 被动连接方
   + SYN_RCVD
   + ESTABLISHED
   + CLOSE_WAIT，当收到FIN,并发送ACK后进入
   + LAST_ACK，当发送FIN,后进入
   + CLOSE，当收到ACK后进入
 
### 
### 问题
 * 大量CLOSE_WAIT
   + 由于程序错误，没有关闭出现异常的连接
   + 通过配置参数缩短超时时间
 
 * 大量LAST_ACK
   + 由于主动方ACK包丢失
     - 重发fin
   + 由于主动方CLOSE
     - 此时直接LAST_ACK重传超时，进入CLOSE
   + 由于主动方商品被其它连接占用
     - 此LAST_ACK会再发送FIN关闭，此时主动会返回RST.最后LAST_ACK进入CLOSE
 
 * 大量TIME_WAIT
   + 服务端尽量不要主动关闭
   + 通过配置缩短TIME_WAIT时间
 
 * 大量FIN_WAIT_2
   + 通过配置超时，时间
   
   
### SYN_RCVD DDos攻击

### ESTABLISHED
 * 客户端正常关闭连接
 * 客记端突然断电
 
###
 
### 断线重连
 * 会导致之前旧的socket连接未正常关闭，占用资源
 * 会重新建立一条连接
 
### MSS Maximum Segment Size
 * 最大报文段长度
 * 表示TCP传往另一端的最大块数据的长度
 * 当一个连接建立时，连接的双方都要通告各自的MSS
 * 如果一方不接收来自另一方的MSS值，则MSS就定为默认值536字节（这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报)。
 * 它能将MSS值设置为外出接口上的MTU长度减去固定的IP首部和TCP首部长度
 * 如果目的IP地址为“非本地的(nonlocal)”
   + MSS通常的默认值为536
 * MSS让主机限制另一端发送数据报的长度，加上主机也能控制它发送数据报的长度，这将使以较小MTU连接到一个网络上的主机避免分段。
 * 系统允许发送的数据长度小于另一端的MSS值
 

### 连接建立超时
 * 如果服务器网络断开，客户端发起连接请求后会出现建立连接超时
   + 大多数默认是75秒，跟据不同系统实现不同
   + 超时前会发出重连请求
   1. 第1次请求大概在6秒左右间隔会发起第2次请求
   2. 第1次请求大概在24秒左右间隔会发起第3次请求
   3. 等待第3次45秒后整个请求超时
   + 总超时大概在75秒左右
   
### MSS Maximum Segment Size
 * 最大报文段长度
 * 表示tcp传往另一端的最大块数据的长度，当连接建立时双方会协商MSS
   + 如果一方不接收来自另一方的MSS值，则MSS就定为默认值536字节
   + 这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报
 * 如果目的IP地址为“非本地的(nonlocal)”，MSS通常的默认值为536
   + 本地的：
     - 如果目的IP地址的网络号与子网号都和我们的相同
   + 非本地
     - 如果目的IP地址的网络号与我们的完全不同
   + 可能是本地的，也可能是非本地的
     - 目的IP地址的网络号与我们的相同而子网号与我们的不同
     - 大多数TCP实现版都提供了一个配置选项，让系统管理员说明不同的子网是属于本地还是非本地
     
 * 避免这种分段
   + 只有当一端的主机以小于576字节的MTU直接连接到一个网络中
   + 如果两端的主机都连接到以太网上，都采用536的MSS，但中间网络采用296的MTU，也将会出现分段
   
### tcp半关闭
 * TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力
   + 一端不能发，只能接
   + 另一端能发，也能接（其实一般也不会接收到数据）
 * A关闭，B正常
   + B可以给A发送数据，同时A也会ack
   + A可以接收B发送的数据
   
### tcp状态转换图


### 连接插口
 * 客户的IP地址和端口号，服务器的IP地址和端口号组成的4元组


### 2MSL等待状态
 * Maximum Segment Lifetime 段最大生存时间
 * TIME_WAIT状态也称为2MSL等待状态
   + rfc 文档指出的是2分钟，一般实现中常用值是30秒，1分钟，2分钟
   
 * TCP连接在2MSL等待期间作用
   + 定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用
   
   + 遗憾的是，大多数TCP实现强加了更为严格的限制
     - **在2MSL等待期间，插口中使用的**本地端口**在默认情况下不能再被使用**
     - SO_REUSEADDR选项可以避开这种限制
     
 * 在连接处于2MSL等待时，任何迟到的报文段将被丢弃
   
 * **尽管许多具体的实现中允许一个进程重新使用仍处于2MSL等待的端口**
   + **通常是设置选项SO_REUSEADDR**
   + **但TCP不能允许一个新的连接建立在相同的插口对上**
   
 * A(19.2.2.35)主动断开连接，则A处于TIME_WAIT状态。 B(10.2.2.33)被动关闭
   + 4元组（10.2.2.35:6666, 10.2.2.33:1098)
      - A启动服务器占用6666端口，B启动客户端使用1098端口连接服务器
      > 在A上6666是本地端口
      - 此时A断开连接关闭服务器，则A->B连接处于TIME_WAIT状态
      - A不能再使用6666（即使设置了SO_REUSEADDR）, 1098端口创建连接，2MSL状态下TCP不能允许一个新的连接建立在相同的插口对上
   + 如果A重新启动服务器使用SO_REUSEADDR，占用6666
      - 此时4元组还处于2MSL状态
      - B可以使用1098继续建立新连接（大多数系统支持），新连接序号ISN号只要大于该连接前个替身的最后序号就可以
      
   1. 如果客户端主动关闭连接
      - 同时重连时会使用不同端口，即时本地端口处于2MSL，也不会出现占用问题
      - 如果使用相同端口，则不能连接
      - 但服务器可以使用相同端口，连接客户端，但一般不会出现这种服务器连接客户端情况 
      
   2. 如果服务器主动关闭连接
      - 一般是SO_REUSEADDR选项，使用相同端口再起动服务器，并不会主动再使用远程端口去连接别人
      - 不会使用相同端口主动发起连接
      - 此时允许客户端使用相同4元组连接服务器（大多数支持），这种情况是特殊情况一般不会出现
      
 * 平静时间的概念
   + 跟主机重启时间有影响，所以在般不会出现。因为主机重启时间肯定会超出MSL
   
   
### 复位报文段
 * 一般来说，不论何时一个报文段发往一个错误连接，tcp都会发出一个复位报文段
 1. 不存在的端口的连接请求
   + 当一个数据报到达目的端口时，该端口没有在使用，它将产生复位
      - udp将产生一个icmp控制报文端口不可达信息
  
 2. 异常终止一个连接
   + 正常方式是发送FIN
   + 异常终止优点
      1. 丢弃任何待发送数据并立即发送复位报文
      2. RST的接收方会区分另一端执行的异常关闭还是正常关闭，应用程序使用的api需要提供处理异常与正常关闭的接口
         - 收到RST的接收方不会产生任何影响，也不进行确认，只是将连接终止，并通知应用层连接复位
         
   + SO_LINGER选项：提供异常关闭能力，将停留时间设置为0，导致连接关闭时进行复位，而不是正常的FIN
   
### 检测半打开连接
 * 如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接称为半打开的
 * 只要不打算在半打开连接上传输数据，仍处于连接状态的一方就不会检测另一方已经出现异常。
   + 所以需要心跳
 * 模拟
   + 把服务器网线拔掉（避免发送FIN），重启服务器主机
   + 重启后，再接上网线
   + 直接连接的客户端，再使用旧的连接发送消息，此时会收到复位
   
### 同时打开与同时关闭
 * 允许
 
### tcp选项

### 呼入连接请求队列
 * backlog
 1. 正等待连接请求的一端有一个固定长度的连接队列，该队列中的连接已被TCP接受（即三次握手已经完成），但还没有被应用层所接受。
   + 注意区分TCP接受一个连接是将其放入这个队列，而应用层接受连接是将其从该队列中移出。
 2. 应用层可以指明该队列的最大长度
 
 3. 如果对于新的连接请求，该TCP监听的端点的连接队列中还有空间，TCP模块将对SYN进行确认并完成连接的建立
   + 当客户进程的主动打开成功但服务器的应用层还不知道这个新的连接时，它可能会认为服务器进程已经准备好接收数据了
   （如果发生这种情况，服务器的TCP仅将接收的数据放入缓冲队列)。
 4. 如果对于新的连接请求，连接队列中已没有空间，TCP将不理会收到的SYN。也不发回任何报文段（即不发回RST）。
 如果应用层不能及时接受已被TCP接受的连接，这些连接可能占满整个连接队列，客户的主动打开最终将超时。
 
### 经受时延的确认
 * 一般为200ms
 * 接入数据后，先不确认，直到有数据发送时，一起返回。如果没有要发送的数据，则等待200ms时延再确认
 
### Nagle算法
 * 在广域网上，这些小分组则会增加拥塞出现的可能
 * Nagle算法 
   + 要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。
     - 如果发送方发送一个数据后没有收到ack，则发送方不能发送数据
     - 不能发送这段时间里，收到的数据将被收集到一起，等待收到ack后一起发送
     > 一般默认时延ack 为200ms, 所以如果接收方没有数据要发送时，则每次发送都会时延200ms
   + 特点
     - 确认到达得越快，数据也就发送得越快
     
 * TCP_NODELAY可以关闭该算法
 
### PUSH标志
 * 发送方使用该标志通知接收方将所收到的数据全部提交给接收进程
   + 这里的数据包括
     - PUSH一起传送的数据
     - 接收方TCP已经为接收进程收到的其他数据
     
 * 目前大多数的API没有向应用程序提供通知其TCP设置PUSH标志的方法。
 的确，许多实现程序认为PUSH标志已经过时，一个好的TCP实现能够自行决定何时设置这个标志。
 
### 滑动窗口
 * 对接收方有效，跟接收缓存大小有关
 * 如果接收方收到数据后，接收缓存中的数据没有被应用层读取，则滑动窗口会变小
 
### 慢启动算法 
 * **单使用滑动窗口控制，在局域网还可以行。而在互联网中，中间路由必须缓存分组，并有可能耗尽存储空间严重降低tcp连接吞吐量**
   + 所以提出慢启动算法 
   
 * 该算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。
 * 慢启动为发送方的tcp增加另一个窗口：拥塞窗口（congestion window）记为：cwnd
 * 当与另一个网络的主机建立tcp连接时，拥塞窗口初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ACK，拥塞窗口
 就增加一个报文段
 * 发送方取拥塞窗口与滑动窗口中的最小值作为同时发送上限。
 * **拥塞窗口是发送方使用的流量控制，滑动窗口是接收方使用的流量控制**
 
### 滑动窗口应该设置为多大的问题
 * 管道的容量公式
   + 带宽时延乘积
   + capacity (bit) = bandwidth (b/s) × round-trip time (s)
 * 接收方的通告窗口必须不小于这个数目（管道容量）
   
 * **带宽**和**时延**均会影响发送方和接收方之间通路的容量
   + 带宽增加一倍时，容量也需要增加。因为数据量变大，占用更多剩余空间
   + 时延增加一倍时，容量也需要增加。因为确认ack变慢，同时还需要有数据可以发送（即滑动窗口有剩余空间）
   
### 拥塞
 * 当数据到达一个大的管道（如一个快速局域网）并向一个较小的管道（如一个较慢的广域网）发送时便会发生拥塞
 * 假定发送方不使用慢启动
   + 它按照局域网的带宽尽可能快地发送编号为1~20的报文段（假定接收方的通告窗口至少为20个报文段）
   + 正如我们看到的那样，ACK之间的间隔与在最慢链路上的一致
   + 假定瓶颈路由器没有足够容纳这20个分组缓存，就会引起路由器丢弃分组
   
### 超时与重传策略
 * 每个连接，TCP管理4个不同定时器
   1. 重传定时器，希望收到另一端确认
   2. 保持定时器，使窗口大小信息保持不断流动
   3. 保活定时器，可检测到一个空闲连接的另一端何时崩溃或重启
   4. 2MSL定时器，可测量一个连接处于TIME_WAIT状态的时间
   
 * 超时重传简单表现
   + 从1秒开始，此后该时间在每次重传时增加1倍并直至64秒。
     - 最后发送一个复位请求
   + 这个倍乘关系被称为**指数退避**
   + 首次分组传输与复位信号传输之间的时间差约为9分钟，这个时间在目前TCP实现中是不可改变的
   
 
### RTT 往返时间测量
 * TCP超时与重传中最重要的部分
   + 对一个给定连接的往返时间（RTT）的测量
   + 通过测量RTT来计算出RTO
   
 * RTO(Retransmission Timeout) 重传超时时间
   + 通过每次更新RTT来更新RTO时间
 
 * 在发送一个报文段时，如果给定连接的定时器已经被使用，则该报文段不被计时
   + 同时只能计一个
   + 只有数据报文段才会被计时，只是一个ACK消息不被计时
   
 * 使用Karn算法超时重传
   + 当一个超时重传发生时，在重传数据的确认最后到达之前，不能更新RTT值
   + 由于数据被重传，RTO已经得到了一个指数退避，我们在下一次传输时使用这个退避后的RTO。
      - 对一个没有被重传的报文段而言，除非收到了一个确认，否则不要计算新的RTO（还使用当前RTO）
      
 * TCP驱动程序有一个500ms定时器，每500ms会tick一次
   + 当发送一个报文时，启动一个RTT计时器，当收到报文ACK后，停止RTT计时器。并返回RTT计时器经过了几次tick
     - 几次tick就表示RTT是多少，如：3次就RTT就是1500ms
   + 如果ACK到达时数据没有被重传，则被平滑的RTT和被平滑的均值偏差将基于这个新测量进行更新。
     
 * RTT估计器的计算
   + 初始值：变量A和D分别被初始化为0和3秒
     - RTO = A + 2D = 0 + 2 × 3 = 6s
     
### 拥塞避免算法
 * 分组丢失就意味着在源主机和目的主机之间的某处网络上发生了拥塞
 * 有两种分组丢失的指示
   1. 发生超时
   2. 接收到重复的确认
   
 * 拥塞避免算法和慢启动算法是相辅相成的是两个目的不同，独立的算法 
 
 * 当拥塞发生时
   + 我们希望降低分组进入网络的传输速率
 * 实现这两个算法需要为每个连接添加两个变量
   1. 一个拥塞窗口cwnd
   2. 一个慢启动门限ssthresh
   
 * 工作过程
   1. 对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节。
   2. TCP输出不能超过cwnd和接收方通告窗口的大小
     + 拥塞避免是发送方使用的流量控制
     + 通告窗口则是接收方进行的流量控制
     
   3. 当拥塞发生时(超时或收到重复确认)
     + ssthresh被设置为当前窗口大小的一半(cwnd和接收方通告窗口大小的最小值，但最少为2个报文段)
     + 如果是超时引起了拥塞，则cwnd被设置为1个报文段（这就是慢启动）。
     
   4. 当新的数据被对方确认时，就增加cwnd。
     + 增加的方法依赖于我们是否正在进行慢启动或拥塞避免
     1. 正在进行慢启动
       - 如果cwnd小于或等于ssthresh
     2. 正在进行拥塞避免
       - cwnd大于ssthresh
     + 慢启动执行时长
       - 慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止，然后转为执行拥塞避免
       - 就是大于ssthresh(因为阻塞时ssthresh会缩小)
       
 * 慢启动算法cwnd增加
   + 初始为1，然后每收到一个确认就加1。
   + 按指数方式增长
   + 将根据这个往返时间中所收到的确认的个数增加cwnd
   
 * 拥塞避免算法cwnd增加
   + 一个往返时间内最多为cwnd增加1个报文段，（不管在这个RTT中收到了多少个ACK）
   + 加性增长
   
 * 一开始是慢启动算法启作用，进入网络的分组数增加的速率仍然是在增加的。
 当cwnd达到一定数量或发生拥塞时（接收重复确认）进入拥塞避免算法，分组增加的速率才会慢下来。
 
### 快速重传与快速恢复算法
 * tcp收到一个失序的报文段时，TCP立即需要产生一个ACK（一个重复的ACK）
   + 该重复的ACK的在于让对方知道收到一个失序的报文段，并告诉对方自己希望收到的序号。
   
 * 我们不知道一个重复的ACK
   + 由一个丢失的报文段引起的
   + 还是由于仅仅出现了几个报文段的重新排序
   
 * 如果一连串收到3个或3个以上的重复ACK，就非常可能是一个报文段丢失了
   + 是我们就重传丢失的数据报文段，而无需等待超时定时器溢出
   + 这就是快速重传算法
   + 接下来执行的不是慢启动算法而是拥塞避免算法。这就是快速恢复算法。
   
 * 执行过程过程
   1. 当收到第3个重复的ACK时，将sstresh设置为当前拥塞窗口cwnd的一半（四舍五入到报文段大小的下一个倍数），
   重传丢失的报文段，设置cwnd为sstresh加上3倍的报文段大小
   2. 每次收到一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组（如果新的cwnd允许发送）
   3. 当下一个确认新数据的ACK到达时，设置cwnd为sstresh。
     + 这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认
     + 这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认
     + 这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。
     
 * 在快速重传和快速恢复阶段
   + 我们收到报文段66、68和70中的重复的ACK后才发送新的数据，而不是在接收到报文段64和65中重复的ACK之后就发送
   + 这因为当前cwnd的取值<=未被确认的数据大小，所以不能发送。只有cwnd增加到大于未被确认的数据大小时才能发
   + 未被确认的数据大小
     - 发送端发送的但没被确认的所有数据报文段大小之和
     
### 重新分组
 * 当TCP超时并重传时，它不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，
 这将有助于提高性能（当然，这个较大的报文段不能够超过接收方声明的MSS）
 
 * 即超时期间，发送的第1个报文与新发送的报文大小 <= MSS 则会将两个报文合并再发送
   
   
### 发送方坚持定时器
 * 来周期性地向接收方查询，以便发现窗口是否已增大。
   + 来避免接收方通知的窗口变更ack丢失
 * 这些从发送方发出的报文段称为窗口探查
 
 * 工作过程
   1. 当接收端通行窗口为0时，发送端开启坚持定时器
     + 如果定时器到了，还没有收到接收端发送的窗口变更，则就探查这个空窗口发以决定窗口更新是否丢失
 * 坚持定时器探查间隔
   + 计算坚持定时器时使用了普通的TCP指数退避。初始为1.5s, 3 * 2， 6 * 2，12 *2 ...
   + 但是坚持定时器总是在5~60秒之间
   + TCP从不放弃发送窗口探查。这些探查每隔60秒发送一次，这个过程将持续到或者窗口被打开，或者应用进程使用的连接被终止。
   
### 糊涂窗口综合症
 * 基于窗口流量控制方案，会导致一种糊涂窗口综合症的状况
   + 导致有小的数据报文被发送
   + 该现象可能发生在两端中的任何一端：
     - 接收方通知一个小窗口（而不是等到一个大的窗口再通知）
     - 发送发送一个小的报文（而不是等到一个大的报文一起发）
   + 可以在任何一端采取措施来避免
   
 * TCP是如何避免的
   1. 接收方不通知小窗口
     + 只有窗口可以增加一个报文大小（也就是将要接收的MSS），能通知
     + 或只有增加接收方缓存空间一半时，能通知。这需要监听每次应用层读取数据
     + 当发送发送探查消息时，接收方还是返回0可用窗口大小（如果不满足上面两条）
   2. 发送避免
     + 只有以下条件之一满足时才发送数据
        a) 可以发送一个满长度的报文
        b) 可以发送到少是接收通知窗口大小一半的报文段
        c) 连接没有使用nagle算法或连接上没有未被确认的数据
        
   b)条件可以应对那些通知小窗口的情况
     + 要求发送方始终监视另一方通告的最大窗口大小
   c)条件可以应对不能使用nagle算法或连接上有未被确认的数据时，发送小数据的操作
   
### 保活定时器
 * 定时器在交换数据后的未来2小时再复位（启动）
 * 2小时后发送一个arp探查
   + 如果失败，则每隔75秒再探查，共进行10次
 
 * 状态
   1. 另一端崩溃
     + 探查结束后，返回一个连接超时。
   
   2. 另一端崩溃并重启成功
     + 探查时，返回连接被对端复位
   
   3. 另一端不可达 
     + 中间路由出现问题
     + 返回icmp网络不可达，之后10次探查后icmp返回没有到达主机的路由。请求结束
     
### 网络包
 * 丢包
 * 误包
 * 超时
 * 连接中断