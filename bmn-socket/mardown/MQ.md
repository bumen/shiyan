## 消息队列 MQ


### 消息必达性
 * 两个核心：消息落地，消息超时、重传、确认

#### 架构
 * 业务调用方+MQ-client
   + 两个核心API
      - sendMsg(byte[] msg)  
      - sendCallback()
 * MQ核心集群
   + MQ-server
   + zk
   + db
   + 管理后台web
 * 业务接收方+MQ-client
   + 核心API
      - RecvCallback(byte[] msg)
      - SendAck()
     
 * MQ是一个系统间解耦的利器
   + 发送方将消息投递给MQ, 上半场
   + MQ将消息投递给接收方, 下半场
    
#### MQ消息可靠投递核心流程
 * MQ将消息拆成上下半场，为了保证消息可靠投递，上下半场必须尽量保证消息必达。
 * 上半场
   + (1) MQ-client通过SendMsg把消息发送给MQ-server
   + (2) MQ-server将消息落地，落地后即为发送成功
   + (3) MQ-server将应答发送给MQ-client（会调用SendCallback）
 * 下半场
   + (4) MQ-server将消息发送给MQ-client（会调用RecvCallback）
   + (5) MQ-client通过SendAck回复消息给MQ-server
   + (6) MQ-server收到ack, 将之前已经落地消息删除，完成消息可靠投递
   
 * 如果消息丢失怎么办
   + 上下半场都有可能丢失，需要MQ进行超时和重传
 * 上半场消息超时与重传
   + 1,2,3步 如果丢失或超时，MQ-client内的timer会重发消息，直到期望收到3，
   如果重传N次后还未收到，则SendCallback回调发送失败。
   需要注意的是，这个过程中MQ-server可能会收到同一条消息的多次重发。
 * 下半场消息超时与重传
   + 4,5,6步 如果丢失或超时，MQ-server内的timer会重发消息，直到收到5，并且成功执行6.
   这个过程可能会重发很多次消息，一般采用指数退避策略，先隔x秒重发，2x秒重发，4x秒重发，以此类推。
   需要注意的是，这个过程MQ-client也可能会收到同一条消息的多次重发。
   
### 幂等性保证
 * 收到重复消息，幂等处理
 * 上半场幂等设计
   + 如果3步丢失，发送端MQ-client是超时后重发，为了避免2步落地消息重复
   每条消息，MQ-client系统内部必须生成一个Inner-msg-id，通过Inner-msg-id去重
   + Inner-msg-id 特性
     - 全局唯一
     - MQ-client生成，具备业务无关性，对消息发送主与接收方透明
   + 其实是保证消息幂等性
   
 * 下半场设计
   + 需要强调的是，接收端MQ-client回Ack给服务器MQ-server时，是消息消费业务方的主动调用行为，不能由MQ-client自动发起。
   + 如果5步丢失，MQ-server会超时重发
   + 为了保证业务幂等性，业务消息会，必须有一个biz-id， 作为去重和幂等依据。这是个业务id
     - 对于同一业务场景，全局唯一
     - 由业务消息发送方生成，业务相关，对MQ透明
     - 由业务消息消费方负责判重，以保证幂等
   + 其实是保证业务幂等性
   
### MQ实现流量消峰填谷
 * 上游调用下游
   + 通过RPC直接调用
   + 通过MQ推送
 * 为什么会有流量冲击
   + 不管理是直接调用，还是MQ推送，都有一个缺点：下游消息接收方无法控制到达自己的流量，如果调用方不限速，很有可能把下游压垮。
   + 如秒杀业务
 * 优化方案两种
   + 上游队列缓冲，限速发送
   + 下游队列缓冲，限速下行
 * 通过MQ做缓冲，而且MQ有消息落地机制
   + 将MQ-client推模式，升级为MQ-client拉模式
   MQ-client每隔一定时间，每次拉取若干条消息，实施流控，达到保护自身效果
   + 如果上游消息量大，MQ-client拉取是可以保护自己，但会不会导致MQ-server消息堆积？
   答：下游MQ-client拉取，可以优化为批量拉取
   
 * 同步消息，则采用队列缓冲