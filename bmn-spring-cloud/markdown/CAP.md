## CAP原则
 * 非关系型数据库，遵循CAP定理。
 * consistency
   + 一致性
 * availability
   + 可用性
   + 减少系统不能提供服务的时间
   + 高可用保证原则是集群化或者冗余 + 自动故障转移
 * partition-tolerance
   + 分区容错
   + 节点连通性与扩展性
   + 节点连通性必须保证
   
### 一致性模型
 * 强一致性
 * 弱一致性
 * 最终一致性
   + 如何保证
     - 冗余数据全量定时扫描
     - 冗余数据增量日志扫描
     - 冗余数据线上消息实时检测
     
 * 因果一致性
 * 读你所写一致性
 * 会话一致性
 * 单调一致性
 * 单调写一致性
 
### 一致性
 * session一致性，架构设计 
   + web应用之间session复制
      - 优点：web服务器支持功能
      - 缺点：session同步需要数据传输，占内网带宽，有时延
      所有web-server有所有session数据，数据量大内存有限，无法水平扩展
      有更多的web-server时要歇菜
   + 客户端保存session，可以存cookie
      - 优点：服务器不需要存储
      - 缺点：每次http都需要带session, 占外网带宽
      在外网传输存在，泄漏、篡改、窃取等安全问题
      session存储数据大小受cookie大小限制
   + 反向代理，hash一致，同一用户请求落在同一台机器上
      - 优点：只需要改nginx，不需要修改服务器
      负载均衡
      可支持web-server水平扩展
      - 缺点：如果web-server重启，则客户端断线
      web-server水平扩展后，rehash后session重新分布。也会有一部用户路由到不正确的session
   + 后端统一存。存数据库或缓存
      - 优点：没有安全隐患
      可以水平扩展
      服务器重启session不会丢失
      - 缺点：增加一次网络调用，并且需要修改应用代码
      - 推荐，使用cache存储
   + session管理服务
      - 统一登录中心，在web-server通过filter请求统一登陆服务器验证登录是否有效
 * 数据库主从一致性，架构设计
   + 读从写少场景采用一主多从，读写分离，冗余多个读库。提高数据库读性能
   + 由于主从延时导致读取到旧数据
   + 方案一：半同步复制，写操作等到主从同步完成再返回
      - 优点：数据原生功能，比较简单
      - 缺点：写请求延时会增长，吞吐量会降低
   + 方案二：强制读主，读写都在主库上
      - 优点：一致性上不需要设计 
      - 缺点：只能通过cache提升系统读性能
   + 方案三：数据库中间件，读写都走中间件
      - 优点：保证数据一致性
      - 缺点：中间件成本高
   + 方案四：缓存记录写key法，通cache 记录写key，当有读操作时，先判断cache是否有写key（过期时间为主从同步延时时间）. 如果有则读主。否则
      - 优点：没有中间件，成本低
      - 缺点：为了保证一致性，需要一次cache。读写都多了一次cache操作
      
 * 数据库双主一致性，架构设计
   + 为了实现写高可用，采用双主模式。提高写可用性。但由于双主同步数据，同步有延时，引发了一致性问题
   + 方案一：相同步长免冲突
      - 主键设置不同值，但是增长步长一样。a库，1，3，5；b库，2，4，6; 同步后为1,2,3,4,5,6
      - 同步后不会都冲突
   + 方案二：使用全局唯一ID
      - 分布式id
   + 方案三：消除双写不治本
      - 取消双写，只有一个主库提供写服务，另一个主库为shadow-master， 只保证高可用。
      - 双主使用相同虚ip, 主库异常后，虚ip漂移
      - 极限情况也会有数据不一致
   + 方案三：内网DNS探测
      - 需要主从同步完成后再实施虚IP漂移
      - 使用内网域名连接数据库。两个主库采用不同ip
      - 一开始域名指向ip1, 
      - 使用脚本探测ip1连通性
      - 当ip1失败，脚本迟延几秒，等待主同步完成。再将域名解析到ip2
      - 使用内网域名进行重连，即可自动连接到ip2， 并保证数据一致性
      
   + 如果是高并发场景，还是一个主库多个从库。
      
 * 数据库与缓存一致性，架构设计
   + 单库情况下，服务层并发读写，缓存与数据库操作交叉进行会出现不一致
      - a写入时，把cache删除，然后a阻塞
      - b读取时，cache没有，去主库读，写入cache. 此时cache是脏数据
   + 主从同步，读写分离，读从库读到旧数据
      - 由于主从同步延时，b读取的旧数据，同步到cache
   + 方案一：写操作完成后，休眠同步延时秒数后，再2次淘汰cache。缓存双淘汰
      - 缺点：降低写请求吞吐量，增长业务处理时间
   + 方案二：缓存双淘汰异步
      - 通过写操作完成，异步启动一个timer来实现第2次cache淘汰
      - 也可以使用消息队列，发给另一个服务实现淘汰
      - 缺点：业务线的写操作增加一个步骤
   + 方案三：新增一个线下的读binlog的异步淘汰模块，读取到Binlog中的数据，异步淘汰缓存
   
 * 数据冗余一致性，架构设计 
 * 消息时序一致性，架构设计
 * 分布式事务一致性，架构设计
   + 补尝
   + 后置提交
   + 2pc, 3pc, tcc
 * 高并发库存扣减一致性，架构设计 

### 
 
### Eurela与Zookeeper区别
 * Zookeeper 是CP
   + 一致性优先，可用性靠后
   + 只向Leader注册
   + 如果Leader挂了，通过在follower选举一个成为Leader（耗时不提供注册，此时不是高可用）,
   同时会把所其它follower同步一样后才能再提供注册功能（实现一致）
 * Eureka 是AP
   + 没有选举
   + 当刚一注册，这台Eureka就挂掉，此时其它Eureka还没有同步过来，造成不一致