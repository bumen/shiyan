## 架构优化

### 实现高并发优化
 * 查看高并发的瓶颈在哪里？
   + 可能是服务器网络带宽不够
   + 可能web连接数不够
   + 可能是数据库查询上不去
 * 高并发指标
   + 响应时间
   + 吞吐量. 每秒处理请求数量
   + QPS(每秒响应请求数)与吞吐量一样
   + 并发用户数-同时在线人数
   
#### 计算网络流量是否够
 * 定位是否流量不够
 * 使用CND加速，
 * 使用腾讯云，阿里云，存放静态文件
 * 可以增加网络带宽
 * DNS域名解析分发多台服务器
 
##### 计算页面每秒请求数
 * 统计日平均PV，APV
 * 一次PV大概200个请求（js/css/img/ajax）
 * APV * 200 = 日平均请求数
 * 通过日平均请求数，一天昼夜比1:10计算，白天(10:00-22:00)12小时，则计算每秒多少个请求
 * 如APV = 6000, 6000 * 200 = 120万，平均白天110万。120万/24/60/60 = 13/s
 
##### 计算带宽数
 * 日平均6000PV
 * 平均200个请求是7MB
 * 总流量是6000 * 7 = 42G
 * 昼夜1：10， 白天38.2G
 * 每秒流量=38.2/12/60/60 = 0.905Mb/s
 * 换算为带宽为7.24Mbps

 
#### web连接数不够，web服务器压力是否正常
 * 压力测试，查看cpu, 内存，io
 * cpu是否100
 * 内存是否溢出
 * io是否出现TIME_WAIT, LAST_ACK太多
 * io是否有服务器消费消息过慢。导致socket接收缓冲区满，造成网络阻塞
 * 解决
   + 频繁使用的对象，使用对象池
   + 使用单例
   + 异步执行，加消息队列
   + 无锁数据结构或乐观锁
   
#### 数据库查询上不去
 * sql查询优化
   + 慢查询
 * 读写分离
 * 分库
 * 加缓存
 
### 高可用 HA
 * 高可用是分布式系统架构设计中必须考虑因素之一
 * 方法论上，高可用保证的原则是“集群化”，或叫冗余
 保证系统高可用，架构设计的核心准则是冗余
 * 往往通过“自动故障转移”来实现系统的高可用。
 
#### 反向代理层高可用
 * 通过CND轮询，多个nginx使用相同virtual ip
 * 如果nginx性能不能满足，则可以使用lvs作为返向代理层组件
 lvs下扩展多个nginx,nginx作负载均衡
 * 通过keepAlived进行存活探测, 自动故障转移
 
#### 站点层web应用高可用
 * 通过配置多台
 * 配置nginx添加多个web后端，nginx能够探测存活，自动故障转移
 
#### 服务层高可用
 * 通过服务连接池实现，请求时随机选取连接来访问下游服务
 * 当server挂了，connection-pool可以探测到，会自动故障转移
 
#### 缓存层高可用
 * 通过通过service层对cache的双读或双写
 * 可以使用主从同步，使用集群来解决高可用
 * redis 天然支持主从同步，通过sentinel哨兵机制，进行存活性探测
 当redis挂了，哨兵自动故障转移。整个过程通过sentinel和redis集群配合完成
 * 缓存不一定高可用，更多对缓存的使用场景，是用来“加速数据访问”
 如果缓存挂了，再去访问数据库。这类允许cache-miss业务场景，建议架构
   + 将kv缓存封装成服务集群，上游设置一个代理（代理可以使用冗余方式保证高可用），
   代理后端根据缓存访问的key进行水平切分，每个实例访问并不做高可用
   + 如果proxy挂了，则cache-miss
   + 如果redis挂了，切分实例只是减少

#### 数据库层高可用
 * 主从同步，读写分离
 * 又分，读库高可用与写库高可用
 * 读库高可用
   + 通过冗余读库，至少2个，通过数据库连接池建立与读库多个连接，每次请求会路由这些读库
   + 如果读库挂了，db-connection-pool可以探测存活，自动故障转移
 * 写库高可用
   + 通过冗余写库，使用两个双主同步，使用keepalived存活探测，使用virtual ip
   当写库挂了，keepalived可以探测到，自动转移故障
   
 