## 字节码执行引擎

### 运行时栈帧结构
 * 局部变量表
   + 由方法表中Code属性确定
 * 操作数栈
   + 由方法表中Code属性确定
 * 动态连接
   + 指向运行时常量池
 * 方法返回地址
 
### 方法调用
 * 确定调用哪一个方法
 * 解析方法
   + 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法在运行期是不可改变。
   + 即在编译器进行编译时就必须确定下来。
   + 符合“编译期可知，运行期不可变”，可以继承与重写
     - 静态方法
     - 私有方法
   + 指令
     - invokestaic: 调用静态方法
     - invokespecial: 调用实例构造器、私有方法、父类方法
     - invokevirtual: 调用所有虚方法
     - invokeinterface: 调用接口方法，运行时确定
   + invokestatic, invokespeical可以在解析阶段确定唯一调用版本
     - 有静态方法
     - 私有方法
     - 构造方法
     - 父类方法
   + 在类加载时，就把符号引用解析为直接引用， 这些方法为非虚方法
   + final方法虽然由invokevirtual调用，但是不可变，也是非虚方法
   + 解析调用一定是静态的过程，编译期就确定，编译期所符号引用解析为直接引用
   
 * 分派
   + 静态类型、实际类型
   + 静态分派
     - 根据静态类型来定位方法执行版本的分派叫静态分派
     - 典型应用是方法重载
     - 虚拟机在重载时通过参数静态类型而不是实际类型作为判断依据。
     - 静态类型是编译期可知的，所以在javac编译器根据参数静态类型决定使用哪个
     重载版本
   + 字面量的静态模糊分派
     - 如：'a'
     - 由于字面量没有显示的静态类型，静态类型只能推断
   
   + 动态分派
     - 典型应用是方法重写
     - 运行时动态查找
 
   + 静态多分派， 动态单分派
     - 静态多分派，根据调用对象与参数来确定调用方法
     - 动态单分派，根据调用对象来确定调用方法