### 王争

#### 定义
 * 数据结构是为算法服务的，算法要作用在特定的数据结构之上。 
 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。
 > 数据结构是静态的，它只是组织数据的一种方式。
 如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。
 
### 复杂度分析
 > 数据结构和算法解决的是如何更省、更快地存储和处理数据的问题。
 因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。
 
 * 掌握基本数据结构10个
   + 数组
   + 链表
   + 栈
   + 队列
   + 散列表
   + 二叉树
   + 堆
   + 跳表
   + 图
   + trie树
 * 撑握基本算法10个
   + 递归
   + 排序
   + 二分查找
   + 搜索
   + 哈希算法
   + 贪心算法
   + 分法算法
   + 回溯算法
   + 动态规划
   + 字符串匹配算法

#### 时间复杂度
 * 公式:
   `T(n) = O(f(n))`
   + T(n)代表代码的执行时间 
   + n表示数据规模大小
   + f(n)表示每行代码执行的次数总和
     - 因为是公式，所以用f(n)
   + O表示代码的执行时间T(n)与f(n)表示式成正比
   + 大O时间复杂度实际上并不具体表示代码真正的执行时间，
   而是表示代码执行时间随数据规模增长的变化趋势
     - 也叫渐进时间复杂度，简称时间复杂度

 * 常见复杂度
   + 多项式的
     - 常量阶O(1)
     - 对数阶O(log n)
     - 线性阶O(n)
     - 线性对数阶O(n *log n)
     - 平方阶n^2
     - k次方阶n^k
   + 非多项式的
     - 指数阶: 2^n
     - 阶乘: n!
     > 当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加.
     求解问题的执行时间会无限增长。
     所以，非多项式时间复杂度的算法其实是非常低效的算法
 
 * 对数阶
  ``` 
    i = 1;
    while(i <= n) {
        i = i * 2;
        // i = i * 3;  即log3^n
    }
    // 1 * 2, 2 * 2, 4 * 2
    // 2^1, 2^2, 2^3
  ```
  + 这是一个等比数列即2^x = n，请解x = log2^n
  即时间复杂度为O(log2^n)
  + log3^n = log3^2 * log2^n
  所以去掉系数后为log2^n，都可以转换为统一形式
  + 最终表示会忽略底数后为log^n
  
* O(m + n)
 ``` 
 
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
 ```
 + 因为无法事先评估m和n谁的量级大，所以要使用O(m+n)
 
* 从低阶到高阶
  1. O(1)
  2. O(log^n)
    + 时间不会变化很大
  3. O(n)
    + 与次数一致
  4. O(n * log^n)
  5. O(n^2)
 
* 同一段代码在不同情况下时间复杂度会出现量级差异 
  + 最好情况时间复杂度
  + 最坏情况时间复杂度
  + 平均情况时间复杂度
    - 最好与最坏是在极端情况下发生的，平均情况复杂度引入了概率，所以也叫加权平均时间复杂度或者期望时间复杂度
    - 只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。
    - 考虑每种可能情况执行的次数K及其对应概率P，所有可能情况的次数与概率分别相乘再相加∑Ki*Pi，然后化简取较大项
  + 均摊时间复杂度
    - 应用的场景特殊、有限。
    - 出现的频率是非常有规律的，而且有一定的前后时序关系

  ``` 
    // n表示数组array的长度
    int find(int[] array, int n, int x) {
      int i = 0;
      int pos = -1;
      for (; i < n; ++i) {
        if (array[i] == x) {
           pos = i;
           break;
        }
      }
      return pos;
    }
  ```
  + 要查找的变化x可能出现在数组的任意位置，
  所以不同情况下这段代码的时间复杂度不一样
  + 最好即array[0] = x时
  + 最坏即array[n]中没有x
  + 我们知道，最好情况与最坏情况时间复杂度对应的都是极端情况下
  的代码复杂度，发生的概率其实并不大。为了更好表示平均情况下复杂度，
  我们引入平均情况时间复杂度
     - 代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。
  
     - 要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。
     我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值
          ``` 
            (1+2+3+...+n + n)/(n+1) = (n(n+3))/2(n+1)
              - 支掉：常数，系数，低阶
              - 即去掉(n*(n))/n = n
              - 最终复杂度为O(n)
            推导
            > 1+2+3+...+n是一个等差数列公式 (1+n)*n/2
            > 主要就是推导分子，1+2+3+...+n+n = n(1+n)/2 + n = n(1+n)+2n /2 = n+n²+2n/2 = n² + 3n /2 = n(n+3)/2
            > 将 n(n+3)/2 代入式子中，就成了 n(n+3)/2 / n+1 = n(n+3) /2(n+1)
          ```
     - 概率分析：要查找的变量x，我们假设在数组中与不在数组中的概率都为1/2
     另外，要查找的数据出现在0～n-1 这n个位置的概率也是一样的为1/n，
     所以，根据概率乘法法则，要查找的数据出现在0～n-1中任意位置的概率就是1/(2n)。
     如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样
         ``` 
            1*(1/2n) + 2*(1/2n) + 3*(1/2n)+...+n*(1/2n)+n*(1/2)
            = (3n+1)/4
             - 这个值就是概率论中的加权平均值，也叫作期望值
             - 去掉系数与常数为O(n)
            推导
            > 1 x 1/2n + 2 x 1/2n + 3 x 1/2n + ..... + n x 1/2n 这里可以转化为 1+2+3+...+n/2n
            > 这里 1+2+3+...+n 是等差数列，等差数列的求和公式： n(1+n)/2 ，将公式套入
            > n(1+n)/4n + n/2 = n(1+n)/4n + n/2 = 1+n/4 + n/2 = 1+n/4 + 2n/4 = 3n+1/4。

         ```
     > 在概率论和统计学中，数学期望(mean)（或均值，亦简称期望）
     是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。
     它反映随机变量平均取值的大小。
         
  + 均摊时间复杂度
     ``` 
         // array表示一个长度为n的数组
         // 代码中的array.length就等于n
         int[] array = new int[n];
         int count = 0;
         
         void insert(int val) {
            if (count == array.length) {
               int sum = 0;
               for (int i = 0; i < array.length; ++i) {
                  sum = sum + array[i];
               }
               array[0] = sum;
               count = 1;
            }
        
            array[count] = val;
            ++count;
         }     
     ```
    - 最好：不满时，O(1)
    - 最坏：array满了时，O(n)
    - 平均：不满时数据插入不同位置+满时即有n+1种情况且发生的概率一样为1/(n+1)
    根据加权平均计算方法
        ``` 
            1*(1/(n+1)) + 1*(1/(n+1)) + 1*(1/(n+1))+...+n*(1/(n+1)) 
            = O(1)
            
        ```
    - 均摊
      - 在大部分情况下，时间复杂度都为O(1)。只有个别情况下，复杂度才比较高，为O(n)
      - O(1)时间复杂度的插入和O(n)时间复杂度的插入，出现的频率是非常有规律的，
      而且有一定的前后时序关系，一般都是一个O(n)插入之后，紧跟着n-1个O(1)的插入操作，循环往复。
      - 把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，
      均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)
    > 两个条件满足时使用：
    1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；
    2）低级别和高级别复杂度出现具有时序规律。
    均摊结果一般都等于低级别复杂度。
     
  


#### 空间复杂度
 * 表示算法的存储空间与数据规模之间的增长关系
 
  
  
  
