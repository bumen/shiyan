### 王争

#### 定义
 * 数据结构是为算法服务的，算法要作用在特定的数据结构之上。 
 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。
 > 数据结构是静态的，它只是组织数据的一种方式。
 如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。
 
### 复杂度分析
 > 数据结构和算法解决的是如何更省、更快地存储和处理数据的问题。
 因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。
 
 * 掌握基本数据结构10个
   + 数组
   + 链表
   + 栈
   + 队列
   + 散列表
   + 二叉树
   + 堆
   + 跳表
   + 图
   + trie树
 * 撑握基本算法10个
   + 递归
   + 排序
   + 二分查找
   + 搜索
   + 哈希算法
   + 贪心算法
   + 分法算法
   + 回溯算法
   + 动态规划
   + 字符串匹配算法

#### 时间复杂度
 * 公式:
   `T(n) = O(f(n))`
   + T(n)代表代码的执行时间 
   + n表示数据规模大小
   + f(n)表示每行代码执行的次数总和
     - 因为是公式，所以用f(n)
   + O表示代码的执行时间T(n)与f(n)表示式成正比
   + 大O时间复杂度实际上并不具体表示代码真正的执行时间，
   而是表示代码执行时间随数据规模增长的变化趋势
     - 也叫渐进时间复杂度，简称时间复杂度

 * 常见复杂度
   + 多项式的
     - 常量阶O(1)
     - 对数阶O(log n)
     - 线性阶O(n)
     - 线性对数阶O(n *log n)
     - 平方阶n^2
     - k次方阶n^k
   + 非多项式的
     - 指数阶
     - 阶乘
     > 当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加.
     求解问题的执行时间会无限增长。
     所以，非多项式时间复杂度的算法其实是非常低效的算法
 
 * 对数阶
  ``` 
    i = 1;
    while(i <= n) {
        i = i * 2;
        // i = i * 3;  即log3^n
    }
    // 1 * 2, 2 * 2, 4 * 2
    // 2^1, 2^2, 2^3
  ```
  + 这是一个等比数列即2^x = n，请解x = log2^n
  即时间复杂度为O(log2^n)
  + log3^n = log3^2 * log2^n
  所以去掉系数后为log2^n，都可以转换为统一形式
  + 最终表示会忽略底数后为log^n
  
* O(m + n)
 ``` 
 
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
 ```
 + 因为无法事先评估m和n谁的量级大，所以要使用O(m+n)
 
* 从低阶到高阶
  1. O(1)
  2. O(log^n)
    + 时间不会变化很大
  3. O(n)
    + 与次数一致
  4. O(n * log^n)
  5. O(n^2)
 
* 不同情况分析 
  + 最好情况时间复杂度
  + 最坏情况时间复杂度
  + 平均情况时间复杂度
  + 均摊时间复杂度
  ``` 
    // n表示数组array的长度
    int find(int[] array, int n, int x) {
      int i = 0;
      int pos = -1;
      for (; i < n; ++i) {
        if (array[i] == x) {
           pos = i;
           break;
        }
      }
      return pos;
    }
  ```
  + 要查找的变化x可能出现在数组的任意位置，
  所以不同情况下这段代码的时间复杂度不一样
  + 最好即array[0] = x时
  + 最坏即array[n]中没有x
  + 我们知道，最好情况与最坏情况时间复杂度对应的都是极端情况下
  的代码复杂度，发生的概率其实并不大。为了更好表示平均情况下复杂度，
  我们引入平均情况时间复杂度
  


#### 空间复杂度
 * 表示算法的存储空间与数据规模之间的增长关系
 
  
  
  
