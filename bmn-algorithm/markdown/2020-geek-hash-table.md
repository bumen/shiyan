### 散列表
 * 主要内容
   + 散列函数
   + 散列冲突

#### 散列冲突
 * 开放寻址法
   + ThreadLocalMap使用线性探测这种方式
   + 开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入
   + 那如何重新探测新的位置呢？
     - 线性探测
     1. 插入：存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止
     2. 查找：否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中
     3. 删除：我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测
       > 注意：不能直接删除，否则可能导致查询时出现未找到
     4. 缺点
       - 当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。
       - 极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n) 
     
     - 二次探测
     
     - 双重散列
       + 意思就是不仅要使用一个散列函数。我们使用一组散列函数
       + 我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置
       
   + 装载因子
     - 我们用装载因子（load factor）来表示空位的多少
     - 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。  
     `散列表的装载因子=填入表中的元素个数/散列表的长度`
     
   + 优点
     - 散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。
     而且，这种方法实现的散列表，序列化起来比较简单。
     
   + 使用
     - 当数据量比较小、装载因子小的时候，适合采用开放寻址法
     
 * 链表法
   + 数组 + 链表
   
   
     
     
