## shell
 * coolshell
 
### 可以处理多行数据
#### awk
 * 对多行的每一行可以截取出列
 * awk '{if($4 ~ /^.{2,3}$/) a[$4]++;} END {for(i in a) print i "," a[i];}' 201809-asr.txt > asr.txt
   ``` 
    2018-09-01 00:00:08.964 1535731008016337784sd112        速度
    2018-09-01 00:00:09.100 1535730953882093530sd112        你唱歌吧
    2018-09-01 00:00:09.145 1535731019294277526sd112        咱也
    2018-09-01 00:00:09.220 1535730987496976490sd112        一首歌叫
   ```
   + START: 表示开始前的处理
   + 每一行都会执行：取出第4列，if 条件正则匹配第4列只有2或3个字的字符串，统计相同串出现次数。
   + END：在统计完成后输出成“字符串，数量”格式，写到文件
   
 * 格式化输出
   + awk '{printf "\"%s\",\n", $1}' asr.txt

#### sort
 * 对多行排序，可以按某一列排序
 * sort [-fbMnrtuk] [file or stdin]
   + -f  ：忽略大小写的差异，例如 A 与 a 视为编码相同；
   + -b  ：忽略最前面的空格符部分；
   + -M  ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；
   + -n  ：使用『纯数字』进行排序(默认是以文字型态来排序的)；
   + -r  ：反向排序；
   + -u  ：就是 uniq ，相同的数据中，仅出现一行代表；
   + -t  ：分隔符，默认是用 [tab] 键来分隔；
   + -k  ：以那个区间 (field) 来进行排序的意思
 * sort -t ',' -k 2nr asr.txt > asr_sort.txt
   ``` 
    来转转,2
    来走,2
    来揍我,2
    来做呀,2
   ```
   + 用“,”号分隔，取第2列，按数字排序，反排序。结果写入asr_sort.txt
   
#### uniq
 * 对重复行去重。只能处理相邻行是重复的，所以一般与sort一起使用
 * uniq -c
   + 统计重复行出现次数
 * uniq -dc
   + 统计重复行出现次数，只显示重复行
 * uniq -u
   + 只显示不重复行

#### cut
 * cut -c 字符区间
   + -d  ：后面接分隔字符。与 -f 一起使用；
   + -f  ：依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思；
   1,7：取1列与7列
   1-7：取1到7列
   1-：取第1列之后所有
   + -c  ：以字符 (characters) 的单位取出固定字符区间；
   
 * 与awk区别，不同重新格式化输出结果
 
 * cut -d ':' -f 1,7 
   ``` 
    root:x:0:0:root:/root:/bin/bash
    bin:x:1:1:bin:/bin:/sbin/nologin
   ```
   + 已“:”分隔，取第1列与第7列
   ``` 
    root:/bin/bash
    bin:/sbin/nologin
   ```