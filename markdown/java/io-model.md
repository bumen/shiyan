### io模型
 * 5种 
 * 阻塞，非阻塞描述是用户线程调用内核IO操作的方式：
   + 阻塞
      - 指io操作需要彻底完成后才返回用户空间
   + 非阻塞
      - 指IO操作被调用后立即返回给用户一个状态值，无需等待IO操作完成
   
   
 * 同步，异步描述的是用户线程与内核交互方式
   + 同步
      - 用户线程发起IO操作后，需要等待或者轮询内核io操作完成后才能继续执行
   + 异步
      - java多线程是实现异步操作的一种方式
      - 用户线程发起IO操作后扔继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。
      
 * 阻塞，非阻塞是相对于调用者
   + 调用者再调用一个方法时被阻塞住了。可能这个方法就是一个同步方法
   + 调用者再调用一个方法时没有被阻塞住。直接返回了。可能是这个方法就是一个异步任务 
 * 同步，异步是相对于被调用者
   + 一般是同步方法，异步任务
   + 调用者再调用一个方法时，该方法就直接执行了。跟调用者是同步的
   + 调用者再调用一个方法时，该方法异步执行了。脱离了调用者
   
 * 组合
   1. 同步阻塞；
   2. 同步非阻塞；
   3. 异步阻塞；
   4. 异步非阻塞；
   
 * 并行
   + 指同时处理相同的任务
 * 并发
   + 指同时处理不同的任务
 
#### 阻塞式 I/O 模型(blocking I/O）
 * 比喻：一个人在钓鱼，当没鱼上钩时，就坐在岸边一直等。
 * 优点：程序简单，在阻塞等待数据期间进程/线程挂起，基本不会占用 CPU 资源。
 * 缺点：每个连接需要独立的进程/线程单独处理，当并发请求量大时为了维护程序，内存、线程切换开销较大，这种模型在实际生产中很少使用。

#### 非阻塞式 I/O 模型(non-blocking I/O）
 * 比喻：边钓鱼边玩手机，隔会再看看有没有鱼上钩，有的话就迅速拉杆。
 * 优点：不会阻塞在内核的等待数据过程，每次发起的 I/O 请求可以立即返回，不用阻塞等待，实时性较好
 * 轮询将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低，所以一般 Web 服务器不使用这种 I/O 模型。


#### I/O 复用模型(I/O multiplexing）
 * 优点：可以基于一个阻塞对象，同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源。
 * 缺点：当连接数较少时效率相比多线程+阻塞 I/O 模型效率较低，可能延迟更大，因为单个连接处理需要 2 次系统调用，占用时间会有增加。


#### 信号驱动式 I/O 模型（signal-driven I/O)
 * 优点：线程并没有在等待数据时被阻塞，可以提高资源的利用率。
 * 缺点：信号 I/O 在大量 IO 操作时可能会因为信号队列溢出导致没法通知。


#### 异步 I/O 模型（即AIO，全称asynchronous I/O）
 * 优点：异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠。
 * 缺点：要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O。


