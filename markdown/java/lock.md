## lock 锁

### AQS
 * CLH链表
   + head<->node<->tail
   + head是一个哨兵节点。0：状态表示后没有要获取锁的节点。-1: 状态表示后面有等待获取锁的节点
   + node: 等待获取锁的节点
   + tail: 尾节点，也是一个node, 但状态是0，因为tail之后没有其它节点
   
 * CLH 添加
   + 原子更新尾结点，更新完成后，将当前添加到链表上
   + 过程
      - add(node)
      - prev = tail         
      - update(prev, node) // 原子更新
      - prev.next = node // 添加到链表上
   
   
 * 链表Entry
   + waitStatus属性：
      - 0：状态表示节点之后没有等待获取锁的节点（即之后没有节点，或这后的节点不需要唤醒）
      - -1：SIGNAL表示，节点之后有等待获取锁的节点
      
 * 唤醒过程
   + unlock过程，必须是lock之后才能unlock. 否则如果不是同一线程会抛异常
   + 唤醒是从head节点开始
   + 更新head节点状态为0，因为下一个节点正准备被唤醒
   + 如果head.next节点是等待获取锁的节点，则直接唤醒。如果不是有效节点（即取消了），则从tail节点一直向前找到head之后第1个有效的节点唤醒
   
 * 等待过程
   + 先判断node.prev节点是不是头节点，不是则修改prev节点状态为SIGNL状态后睡眠
   + 每次线程睡醒之后都判断prev是不是头节点, 如果是则尝试获取锁成功返回，失败继续睡
   + 如果获取锁过程中抛出异常，则获取锁失败。删除当前节点
      

### ReentrantLock 独占锁
 * 
 
### ReentrantReadWriteLock 读写锁
 * Write Lock
   + 获取写锁，
     - 没有读锁，没有写锁，原子获取
     > 非公平，原子获取
     > 公平，同步队列有共他节点
     
     - 有读锁，没有写锁，不能获取
     - 有读锁，有写锁，是当前线程获取写锁的线程，能获取
     
   * 有读锁时不能获取写锁。因为多个线程获取读锁。即锁不能升级，可以降级
   * 写锁可以重入
   
 * Read Lock
   + 获取读锁
     - 有写锁，不是当前线程，不能获取
     - 判断公平性
     > 非公平，如果CLH队列第一个节点是等待写锁（write node），则循环更新获取
     >> 已经获取过读锁的可以再获取
     >> 还没有获取读锁的thread, 需要等待
     > 公平，如果CLH队列有其它节点
     >> 已经获取过读锁的可以再获取
     >> 还没有获取读锁的thread，则需要等待
   + 获取
     - 阻塞判断成功时，已经获取的可以再获取。没有获取的阻塞 
     - 阻塞判断失败时，都可以获取
     
   + 有写锁时，如果是当前线程时，可以获取读锁。即锁降级
   + 读锁可以重入
   
### ConditionObject
 * 只有独占锁才能创建
 * await实现
   + 创建node. 添加到condition链表
   + release lock node
   > 必须之前获取锁
   + 阻塞
   + 再获取锁
   
 * single实现
   > 必须之前获取锁
   + 将node, 添加到CLH链表
   + 唤醒当前线程
   
### Semaphore
 * 通过共享锁实现
 * 获取信号
   + 如果剩余数量小于0，则阻塞等待
 * 释放信号 
   + 每次释放后，都去唤醒阻塞的节点
   
### CountDownLatch
 * 通过共享锁实现
 * 获取锁
   + latch > 0 就阻塞
   
 * 释放
   + latch == 0 就通知唤醒所有阻塞线程