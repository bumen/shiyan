
* ![命令开头]
    + 查找[命令开头] 最近 次与之相匹配的命令并执行。
* history -c 清除history
* alias 查看别名
* alias 别名='实际命令'
    + 设置别名
* unalias 别名
    + 取消别名
* unalias -a 
    + 取消所有别名
### 标准输入，输出
* 0 标准输入
* 1 标准输出
* 2 标准错误

### 重定向
* > 覆盖
* >> 追加
* 标准输入重定向
    + 如：< file.txt
    + 将键盘输入改为读取文件输入
* 标准错误重定向
    + 2>
* 标准输入输出重定向
    + 即0< 1> 可以省略0,1编号即。<, > 
* 标准输出与错误重定向
    + &>
### 管道操作
 * “|”：左侧命令输出结果，将作为右侧命令的输入
 
### shell变量
 
#### 用户自定义变量
* 只有用户自己的shell环境中有效，因此又称为本地变量
* 定义
    + 变量名=变量值
* 查看和引用
    + $变量名
    + 当变量名容易和紧跟其后的其他字符相混淆时，需要添加大括号“{}”将其包围起来
    如：${DAY}morning
* 变量赋值
    + = 后边直接指定变量值
    + 变量值可以操作包括双引号、单引号、反撇号、read命令
* 双引号：
    + 允许在双引号内使用$符号来引用其他变量的值。
    + 在简单的赋值操作中，双引号有时候可以省略
    + 如：today="today is $DAY"
* 单引号
    + 不允许在单引号的范围内引用其他变量的值
* 反撇号
    + 允许将执行待定命令的输出结果赋给变量
    + 反撇号内包含的字符串必须是能够执行的命令
    + 在需要使用嵌套命令替换操作时，这时可以将反撇号用$()来代替
    如：disk = $(rpm -qf $(which fdisk))
* read命令
    + read命令可以从终键盘读取输入，
    + read读入一行内容，并以空格为分隔符，将读入各字段分别赋值指定列表中的变量（多余的内容赋值给最后一个变量）
    + -p 提示信息
* 清除自定义变量
    + unset a b c
    清除a, b, c 三个变量

#### 设置变量的作用范围
 * 自定变量只能在当前shell环境中使用，称为局部变量。在新开启的子shell环境中是无效的
 * 通过 export命令将指定变量设置为“全局变量”，直接写变量名，多个变量用空格分隔
    export 可以同时赋值变量
    如： export month=may

#### 变量数值运算
* bash程序并不适合进行强大的数学运算（如小数，指数）。一般只是进行简单的整数运算
* expr 变量1 运算符 变量2 [运算符 变量3]...
    + "+"：加法
    + "-"：减法
    + \*：乘法
    + /：除法
    + %：求模
    
#### 变量替换
* 使用这些特性时，整个表达式需要用花括号括起来
  + ${VAR:=”some default”}
  + 用来替换的内容可以是字符串、一个变量、命令的输出
* :- (默认值替换)
  1. a变量未定义
    - echo ${a:-123} 输出123
    - echo $a 为空
  2. a变量定义且为空
    - echo ${a:-123} 输出123
    - echo $a 为空
  3. a=456 变量定义不为空
    - echo ${a:-123} 输出456
    - echo $a 为456
  * 作用不会对变量进行赋值操作，只有使用${a:-xx}时且满足条件(1,2)时则输出被替换为：xx
* - 
  1. a变量未定义
    - echo ${a:123} 输出123
    - echo $a 为空
  2. a变量定义且为空
    - echo ${a-123} 输出空
    - echo $a 为空
  3. a=456 变量定义不为空
    - echo ${a:-123} 输出456
    - echo $a 为456
  * 作用不会对变量进行赋值操作，只有使用${a-xx}时且满足条件(1)时则输出被替换为：xx

* := (默认值设置)
  1. a变量未定义
    - echo ${a:=123} 输出123
    - echo $a 输出123
  2. a变量定义且为空
    - echo ${a:=123} 输出123
    - echo $a 输出123
  3. a=456 变量定义不为空
    - echo ${a=123} 输出456
    - echo $a 为456
  * 作用会对变量进行赋值操作，只有使用${a:=xx}时且满足条件(1,2)时则输出被替换为：xx。且a也会被赋值为: xx
* = 
  1. a变量未定义
    - echo ${a=123} 输出123
    - echo $a 输出123
  2. a变量定义且为空
    - echo ${a=123} 输出空
    - echo $a 输出空
  3. a=456 变量定义不为空
    - echo ${a=123} 输出456
    - echo $a 为456
  * 作用会对变量进行赋值操作，只有使用${a=xx}时且满足条件(1)时则输出被替换为：xx。且a也会被赋值为: xx

* :? (错误判断)
   1. a变量未定义
     - echo ${a:?123} 输出123, 并输出错误
     - echo $a 输出空
   2. a变量定义且为空
     - echo ${a:?123} 输出123, 并输出错误
     - echo $a 输出空
   3. a=456 变量定义不为空
     - echo ${a:?123} 输出456
     - echo $a 为456
   * 作用不会对变量进行赋值操作，只有使用${a:?xx}时且满足条件(1,2)时则输出被替换为：xx。同时抛出错误
* ?
   1. a变量未定义
     - echo ${a?123} 输出123, 并输出错误
     - echo $a 输出空
   2. a变量定义且为空
     - echo ${a?123} 输出空
     - echo $a 输出空
   3. a=456 变量定义不为空
     - echo ${a?123} 输出456
     - echo $a 为456
   * 作用不会对变量进行赋值操作，只有使用${a:?xx}时且满足条件(1)时则输出被替换为：xx。同时抛出错误
   
* :+  (与默认值替换相反)。但也是替换不设置设置
   1. a变量未定义
     - echo ${a:+123} 输出空
     - echo $a 输出空
   2. a变量定义且为空
     - echo ${a:+123} 输出空
     - echo $a 输出空
   3. a=456 变量定义不为空
     - echo ${a:+123} 输出123
     - echo $a 为456
   * 作用不会对变量进行赋值操作，只有使用${a:+xx}时且满足条件(3)时则输出被替换为：xx
* +
   1. a变量未定义
     - echo ${a+123} 输出空
     - echo $a 输出空
   2. a变量定义且为空
     - echo ${a+123} 输出123
     - echo $a 输出空
   3. a=456 变量定义不为空
     - echo ${a+123} 输出123
     - echo $a 为456
   * 作用不会对变量进行赋值操作，只有使用${a=xx}时且满足条件(2,3)时则输出被替换为：xx



#### 环境变量
* 环境变量指用户登录后Linux系统预先设定好的一类shell变量
    + 用户宿主目录
    + 命令查找路径
    当用户未指定完整路径名执行命令时，shell程序将在哪些目录以及按何种顺序查找该命令对应的可执行文件
    + 用户当前目录
    + 登录终端等
* 查看环境变量
    + 直接使用set
* 环境变量配置文件
    + /etc/profile：全局配置文件
    + /home/xx/.bash_profile：用户配置文件

#### 位置变量
* $1-$9

#### 预定义变量
* $#：命令行中位置参数的数量
* $*：所有位置参数的内容
* $?：表示命令执行后返回的状态，用于检查上一个命令的执行是否正确。
命令退出状态为0表示命令执行正确，非0表示命令执行错误
* $$：当前进程的进程号
* $!：后台运行的最后一个进程的进程号
* $0：当前执行进程的进程名

#### 编写shell脚本文件
* 运行环境设置
    + 设置时以“#!/bin/shell”开始
* 执行shell
    + bash | sh a.sh：是在子shell来运行
    + "."：是在当前shell环境中运行

#### 条件测试操作
* 返回0表示成功，非0表示失败
* test 条件表达式   或者 [    条件表达式   ]
    + 使用 "[" 或 “]" 与条件表达式语句之间至少需要有一个空格
* 条件测试后可以通过 $?获得命令执行是否成功
* 测试文件状态
    + -d：是否为目录
    + -e：目录或文件是否存在
    + -f ：是否为文件
    + -r：当前用户是否有权限读取
    + -w：当前用户是否有权限写入
    + -x：当前用户是否可以可执行文件
    + -L：是否为符号连接文件
    + 如：[ -e /etc/passwd ] && echo yes
* 整数值比较
    + -eq：等于
    + -ne：不等于
    + -gt：大于
    + -lt：小于
    + -le：小于或等于
    + -ge：大于或等于
    + 如：[ `who | wc -l` -le 10 ] && echo yes 测试当前登录到系统的用户数小于或等于10
* 字符串比较。两个串之间有空格 a = b 
    + =：匹配
    + !=：不匹配
    + -z：字符串是否为空
    + 如：[ $filepath = "/etc/inittab" ] && echo YES
    [ -z `cat zero.file` ] && echo yes
* 逻辑测试
    + &&：且，使用test测试时，可以使用-a
    + || ：或，使用test测试时，可以使用-o
    + ! ：否
#### if
* 单分支语句
    if 条件测试命令
    then
        命令序列
    fi
    + then 关键字可以与if写一行中，其间通过 分号;进行分隔即可
    if 条件测试命令 ; then 
        命令序列
    fi
    + 分号也可以作为多条命令的分隔符。
* 双分支语句
    if 条件测试命令
    then
        命令序列1
    else
        命令序列2
    fi
* 多分支语句
    if 条件测试命令1
    then
        命令序列1
    elif  条件测试命令2
    then
        命令序列2
    else
        命令序列3
    fi

#### for
    for 变量名 in 取值列表
    do
    命令序列
    done
    + 取值列表以空格分隔的多个值

#### while
    while 条件测试命令
    do
    命令序列
    done
    
#### case
    case 变量值 in
        模式1）
    命令序列1    
    ;;
        模式2）
    命令序列2
    ;;
        模式3）
    命令序列3
    ;;
        *)
    默认执行命令序列
    esac
    + 模式：[0-9] 表示连续范围。 | 表示或

#### until
    until 条件测试命令
    do
        命令序列
    done
    + 当条件不成立成执行。条件成立后停止

#### shift
* 位置变量（$1-$9）中的命令行参数会依次向左传递

#### shell 函数
* function 函数名 {
    命令序列
   }
   或
   函数名() {
    命令序列
   }
* 参数传递
    + 通过位置变量实现参数传递
    + 如： add() { echo `expr $1+$22`}  调用：add 1 2
