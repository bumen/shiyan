### 第5章
 
 
### 指针
 * C 语言保证，0 永远不是有效的数据地址，因此，返回值 0 可用来表示发生了异常事件
   + #defined NULL 0 // 通过null表示一个空指针
   
 * 通用指针的类型
   + void *
   
 * 每个指针都必须指向某种特定的数据类型
   + 指针必须有类型
   
 * *ip += 1
   + 等于：++*ip或(*ip)++，语句(*ip)++中的圆括号是必需的
   + 类似于*和++这样的一元运算符遵循从右至左的结合顺序。
   
 * 指针与数组的相互映射
   + int a[10];
   + int *pa;
   + pa = &a[0]; 指针指向数据第1个元素的地址
      - 因为数组名所代表的就是该数组最开始的一个元素的地址
      - 所以，赋值语句 pa=&a[0]也可以写成下列形式：  
      `pa = a;`  
   + a[0] = *pa
   
   + a[i] 等价于 *(a+i)
      - &a[i] = a+i
   + pa[i] 等价于 *(pa + i)
      - 一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现。
      
      
   + 指针与数组区别 
      - 指针是变量，数组名不是变量
      - 语句 pa=a 和 pa++都是合法的
      - 类似于 a=pa 和 a++形式的语句是非法的。不是变量就不能被赋值
      
   + 当把数组名传递给一个函数时，实际上传递的是该数组第一个元索的地址
      - 可以使用指针参数来代替数组参数使用
      
 * 指针也可以初始化
   + 对指针有意义的初始化值只能是 0 或者是表示地址的表达式
   + 表达式所代表的地址必须是在此前已定义的具有适当类型的数据的地址
     - 如：char allocbuf[1000]; char *allocp = allocbuf;
     - 等同：char *allocp = &allocbuf[0]
     
 * 指针比较运算
   + 如果指针 p 和 q 指向同一个数组的成员,那么它们之间就可以进行类似于==、!=、<、>=的关系比较运算
   + 指向不同数组的元素的指针之间的算术或比较运算没有定义
     
   
 
 * 指针地址算术运算
   
   
### 字符指针与函数
 * 字符串常量是一个字符数组
   + 如："I am a string"
   + 在字符串的内部表示中，字符数组以空字符'\0'结尾，所以，程序可以通过检查空字符找到字符数组的结尾。
   + 字符串常量占据的存储单元数也因此比双引号内的字符数大 1
   
   
### 函数指针 
 * 函数本身不是变量，但可以定义指向函数的指针
 * 函数指针可以被赋值，存放数组，传递给函数，作为函数返回值
 
 
### 指针数组
 * 声明char *lineptr[10];
 * 添加
   + char *p;
   + lineptr[0] = p;
 * 取出
   + chat *p;
   + p = lineptr[0];
  
 * *lineptr++
   + 从头一直取 
   + *lineptr 表示首元素
   + lineptr++ 表示地址加1
   
### 指针运算
 * 赋值
   + 有效的指针运算包括相同类型指针之间的赋值运算
 * 加加减减
   + 指针同整数之间的加法或减法运算
   
 * 合法：指向相同数组中元素的两个指针间的减法或比较运算
   + 相同的两个指针：减法，比较
 * 非法：例如两个指针间的加法、乘法、除法、移位或屏蔽运算
   
   
### 多维数组
 * 如果将二维数组作为参数传递给函数，那么在函数的参数声明中必须指明数组的列数，数组的行数没有太大关系
   + 因为前面已经讲过，函数调用时传递的是一个指针，它指向由行
     向量构成的一维数组，其中每个行向量是具有 13 个整型元素的一维数组
   
   
### 指针使用
 * 指针数组
   + 字符串类型的指针数组
      1. 声明：char *argv[];
      2. 使用：(*++argv)[0], 表示取第一个指针指向的字符串的第一个字符地址
         - [] 比 ++ 和*优化级高，所以需要加括号
         - (*++argv) = ++argv, *argv, 即先将数组下标加1，再取出指针指向的值
      3. 使用：*++argv[0], 表示从一个字符串第一个字符开始向后取出每一个字符
         - argv[0] = p 表示字符串中首字符
         - *++p 每次该字符串后移一个位置并取出值
         
         
 * *p++
   + 先取*p的值，然后再p++
 * *++p
   + 先++p, 然后再取*p的值
   ``` 
    *p++ = val; /* 将 val 压入栈 */
    val = *--p; /* 将栈顶元素弹出到 val 中 */
   ```