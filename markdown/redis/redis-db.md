## redis 数据库

### redisServer
 * dbnum属性：数据库个数。默认16
   + 配置：databases
 * redisDb 数据库数组
 * 切换数据库：默认使用0数据库
   + select 0
 * 数据库键空间dict
 * expires dict
   + 存放键对应过期时间
   
 * saveparam 
   + 保存rdb save配置
 * dirty
   + 自上次执行成功save或bgsave后，服务器进行了多少次修改（write, del, update）
 * lastsave
   + 记录上次执行成功save或bgsave的时间
   
 * aof_buf缓冲区
 
 * clients链表：保存所有连接的客户端
   
### redis 过期key 删除策略
 * 定时：不用
 * 惰性
 * 定期：需要确定删除时长与频率
   + 遍历所有数据库
   + 每个库检查key的数量
   + 随机取某些key判断过期
   
 * rdb 保存
   + 不会保存已经过期的Key
 * rdb 加载
   + 主库加载，不会加载已经过期的key
   + 从库加载，所有key
   
 * aof写入
   + 如果某个键已经过期，但没有被惰性和定期删除掉还。aof会存这个键
   + 但触发删除时，会写一个del key命令到aof中
   
 * aof重写
   + 程序会检查已经过期的key, 过期的key不会被写入aof
   
 * 复制
   + 复制模式下。从服务器的过期键删除动作由主服务器控制
   + 主服务器删除一个过期键后，会显式地向所有从服务器发送一个del命令
   + 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会删除，而继续像处理未过期的键一样返回这个键值
   
 
### 通知
 * 配置：notify-keyspace-events
 * 键空间通知
   + 某个键执行了什么命令
 * 键事件通知
   + 某个命令被什么键执行了
   
### rdb持久化
 * 手动与自动 
 * 手动
   + save：主进程保存，会阻塞
   + bgsave: 启动子进程保存
 * 还原
   + 服务器启动时会自动加载disk rdb文件
   + 过程
      - 因为aof更新频率比rdb文件更高，所有优化使用aof还原
      - 判断是否开户AOF持久化功能：如果开启使用aof还原
      - 未开启，使用rdb还原
   + 服务器阻塞，直到还原完成
    
 * save时
   + 客户端发的所有命令请求都会拒绝
 * bgsave时
   + 拒绝再次调用的save, bgsave。
   + bgsave 与bgrewriteaof不能同时执行
   + bgsave执行时，那么客户端请求bgrewriteaof命令被延时到bgsave执行完
   + 如果bgrewriteaof执行时，bgsave被拒绝
     - 因为两个都是启动子进程，如果两个子进程都执行大量磁盘操作，影响性能
     
 * 自动bgsave配置
   + save 900 1
   + save 300 10 300秒内，数据库进行了10次修改
   + 服务器serverCron, 每隔100ms执行一次，对正在运行的服务器进行维护
   其中一项工作是判断save选项是否满足，满足就执行bgsave
   
 * rdb格式
   ``` 
    +-----+----------+---------+---+---------+
    |redis|db_version|databases|EOF|check_sum|
    +-----+----------+---------+---+---------+
    
    redis是标识
    db_version是版本
    databases是有数据的数据库
    EOF表示结束
    check_sum表示检验合，判断rdb是否损坏
    
    databases: 如db0, db3有数据
    +----+----+
    |db0 |db3 |
    +----+----+
    
    +--------+---------+---------------+
    |selectdb|db_number|key_value_pairs|
    +--------+---------+---------------+
    
    +--------+-+---------------+---------+-+---------------+
    |selectdb|0|key_value_pairs|selectedb|3|key_value_paris|
    +--------+-+---------------+---------+-+---------------+
   ```
   + key_value_pairs
     - 数据部分：如果带过期的键，过期时间也会被保存
     ``` 
      -- 不带过期的key
      +----+---+-----+
      |type|key|value|
      +----+---+-----+
      -- 带过期的key
      +-------------+--+----+---+-----+
      |EXPIRETIME_MS|ms|type|key|value|
      +-------------+--+----+---+-----+
     ```
     - string类型：整形原样，字符型小于20字节原样，大于20字节压缩
     如果配置了rdbcompression yes, 才会压缩
     
### aof持久化
 * aof持久化功能实现可分为
   + 命令追加
   + 文件写入
   + 文件同步
 * 命令追加
   + 服务器执行完一个写命令后，将命令追加到aof_buf缓冲区的末尾
   
 * 文件写与同步
   + 服务器时由事件循环触发处理客户端命令，返回结果
   + 每次循环一次最后时，判断是否写入aof
     - 跟据配置：appendfsync 
     - always：将aof_buf写入文件后并同步到aof文件
     - everysec：将aof_buf缓冲区写入文件。每秒同步文件，同步操作由一个线程专门负责执行。（默认）
     - no: 将aof_buf缓冲写入文件，但不同步文件。同步由操作系统决定 
     
 * aof重写
   + 随着时间长，aof文件越来越大，可能会影响服务器。同时原还数据大
   + 所以需要重写 
   
 * aof重写实现
   + 遍历所有数据库，遍历所有数据一条条写入
   
 * aof后台重写
   + 使用子进程
   + 子进程重写期间，服务器进程可以继续处理命令请求
   + 子进程带有服务器进程数据副本，使用子进程而不是线程，可以避免使用锁的情况下，保证数据安全性
   + 子进程重写时，主进程会继续处理客户端请求，则就会导致数据不一致
     - 设置一个AOF重写缓冲区
     - 主进程写完命令后再将命令写入aof缓冲区，再写入aof重写缓冲区
     - aof缓冲区，会被定期写入和同步到现有aof文件
     - 子进程重写完了，会向主进程发信号，主进程处理这个信号 
   + 主进程处理信号
     - 将aof重写缓冲区中的所有内容写入到新的aof文件
     - 将新的aof文件改名，原子覆盖现有aof文件
     - 这个信号处理完后，父进程可以继续接客户端请求了
   + 整个过程只有处理子进程信号时阻塞主进程
   
### 文件事件
 * 即io事件，表示客户端与服务端的通信事件
   
### 时间事件
 * serverCron函数
   + 配置: hz 10 默认， 一秒10次
   + 负责执行
      - 更新服务器名类统计信息
      - 清理数据库中过程键
      - 关闭和清理连接失效客户端
      - 尝试aof, rdb持久化
      - 如果是主服务器，那么对从服务器进行定期同步
      - 如果处于集群模式，对集群进行定期同步和连接测试
   ``` 
    def main():
      init_server()
      while server_is_not_shutdown():
        aeProcessEvents()
        
      clear_server()
      
    def aeProcessEvents():
      等待文件事件产生
      处理文件事件
      处理已达到的时间事件
   ```
   
### 客户端
 * client list 显示所有客户端
 * 属性
   + fd: 套接字：-1 表示伪客户端，大于-1为真实客户端
   
 * 关闭客户端
   + 多种情况下会关闭客户端
      - 如果客户端发送的命令请求大小超过了输入缓冲区限制大小（默认1G），那么这个客户端被服务器关闭
      - 如果要发送给客户端的命令回复的大小超过了输出缓冲区限制大小，那这个客户端也会被服务器关闭
      
   + 服务器使用两种模式来限制客户端输出缓冲区大小
      - 硬性限制：如果输出缓冲区的大小超过硬性限制所设置大小，那么服务器立即关闭客户端
      - 软性限制：输出输出缓冲区的大小超过了软性限制所设置大小，但还没超过硬性限制，那么服务器将客户端属性记录
      下客户端到达软性限制的起始时间；之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并持续时间
      超过服务器设置定的时长，那么服务器将关闭客户端；相反地，如果不在超过，客户端不会被关闭
      - 配置普通客户端，从服务器客户端，执行发布与订阅功能的客户端
      ``` 
        client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds> 
        client-output-buffer-limit normal 0 0 0
        client-output-buffer-limit slave 256mb 64mb 60
        client-output-buffer-limit pubsub 32mb 8mb 60
      ```
      
      
      