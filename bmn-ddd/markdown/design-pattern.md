### Dirty hack
 * 以不符合设计原理 / 不易维护 / 不易调整 / 不够健壮 / 不够美观的方式解决问题。
 

## 可维护性

### 软件可维护性低原因
   + 僵硬：新加功能，可能涉及到其它地方的也要修改
   + 脆弱：改一个地方，可能导致其它地方出错
   + 复用率低：重复代码太多
   + 黏度过高：功能不容易被替换（包括删除），此只使用其它方式实现
 
### 一个好系统的设计目标-可维性
 * 实现可扩展性
   + 避免僵硬
   + 增加一个功能不会影响其它功能
   + 增加对抽象接口复用
   + 开-闭原则，里氏代换原则，依赖倒转原则，组合/聚合原则
 * 实现灵活性
   + 避免脆弱
   + 对一个功能的修改不会影响到其它功能
   + 减少模块间通信，保持各模块间独立
   + 开-闭原则，迪米特法则，接口隔离原则
 * 实现可插入性
   + 代替功能不会有影响，一个零件坏了，可以替换为另一个零件
   + 增加对抽象接口复用
   + 开-闭原则，里氏代换原则，组合/聚合原则，依赖倒转原则
   
## 系统的重要特性
 * 通过这两个特性来实现系统的设计目标
 * 可复用性
   + 提高生产效率
      - 只要从成本考虑，复用越高，开发成本越低
   + 提高软件质量
      - 一个功能有缺陷时，可以更快被删除，替换
   + 改善系统可维护性
      - 复用性越高，就越可以被替换
 * 可维护性
 
## 可复用性
 
### 传统可复用性
 * 代码复用
 * 算法复用
 * 数据结构复用
 * 缺点
   + 破坏可维护性
   > 如：A与B两个功能都使用C模块。如果A需要增加C的一个新的行为时，但B不需要时。
   > 如果坚持复用，就降低了可维护性。
   > 如果保持可维护性，就要放弃复用。
   >> 所以可维护性与可复用性有共同性的两个独立特性
 * 所以要使用支持可维护性的复用
 
### 可维护性的复用
 * 怎么设计可才能即提高可维护性，也实现系统复用
 * 面向对象设计
   + 可维护性复用是以设计原则和设计模式为基础的
   
## 设计原则
 
### 开闭原则
 * 对扩展开放，对修改关闭
 * 使用：
   + 对可变性的封装原则。即不同变化通过具体子类实现
 * 其它设计原则都是开-闭原则的手段和工具
 
### 里氏代换原则
 * 任务基类可以出现的地方，子类一定可以出现
 * 里氐代换原则是对开闭原则的补充。违反里氏代换原则也就违反开闭原则，反过来不成立
 * 子类可以替换父类，反过来不一定成立
   + java编译器可以保证这一点。子类实现的父类接口要宽由父类接口
 
### 依赖倒转原则
 * 要依赖于抽象，不要依赖于实现
 * 依赖倒转原则是实现开闭原则的手段，开闭原则是目标。违反依赖倒转原则就不可能达到开闭原则的要求。
   + 如果要实现开闭原则，必须使用依赖倒转
   
### 合成/聚合原则
 * 尽量使用合成/聚合原则，则不是使用继承关系达到复用
 * 合成/聚合原则与开闭原则相辅相成，又是实现开闭原则具体步骤的规范。
   + 优先考虑使用合成/聚合关系，在使用继承关系时，必须确定这个关系是符合一定条件的
   + 合成/聚合原则是实现开闭原则的必要条件；违反这一原则就无法系统实现开闭原则这一目标
   + **合成/聚合原则是实现开闭原则中的一个步骤，还有其它步骤（继承）。这几个步骤合在一起就可以系统的实现开闭原则**
   
 * 聚合：表示拥有关系或者整体与部分的关系
 * 合成：表示一种强得多的拥有关系。部分与整体生命周期一样。一个合成的新的对象完全拥有对其组成部分的支配权，
 包括创建和泯灭。一个成分对象在同一个时间只能属于一个合成关系
 *  可以将已有对象纳入到新对象中，使之成为新对象的一部分因此新对象可以调用已有对象的功能
 * 与里氏代换联合使用
   
 >> 继承是强关联。聚合是弱关联
 >> 强关联在编码期已经确定，无法在运行期动态改变
 >> 弱关联在运行期可以动态改变的关联
 
### 迪米特法则
 * 迪米特法则设计出来的系统在功能需要扩展时，会相对更容易地做到修改的关闭。是通向开闭原则的道路
   + 是实现开闭原则的另一种方式 
   
### 接口隔离原则
 * 接口隔离原则限制了通信的宽度，通信应该尽可能地窄。在系统功能扩展的过程当中，不会将修改的压力传递到其他对象。
   + 是实现开闭原则的另一种方式
   
 
## 设计模式
#### 建造模式 7种
 * 简单工厂
   + 工厂类不满足开闭原则：因为新加产品需要修改工厂。它决定哪一个产品类应该被实例化。
   + 产品类满足开闭原则
 * 工厂方法
   + 对简单工厂模式的抽象。支持工厂类满足开闭原则，通过创建不同工厂来创建不同产品。
   + 针对一个产品等级结构
 * 抽象工厂
   + 针对多个产品等级结构
   + 新增产品族支持开闭原则
   + 新增产品等级结构需要修改原来抽象工厂。不支持开闭原则
 * 单例
   + 枚举实现
   + 饿汉
   + 懒汉
   + 线程安全懒汉
   + 线程安全双重检查
   + 静态内部类
 * 多例
 * 建造者
   + 一般是建造步骤相同，但建造不同的产品时使用。不同属性按顺序赋值可以使用。如果只有一个产品也可以使用
   + 导演者角色：负责构造过程一般不省略。如：protobuf的业务类中创建msg,业务类充当导演者角色
   + 抽象建造者：抽象建造步骤+返回建造产品（可以是抽象产品, 可以创建不同产品）。一般可以省略。如：protobuf中没有省略
   + 具体建造者：具体建造步骤+返回具体产品。如: protobuf中的builder
   一般可以把具体建造者与产品角色合并
   
 * 原型模式
   + 给明一个原型对象指明要创建的对象类型，然后复制这个原型对象的办法创建出更多同类型对象
   + java clone满足条件
      - x.clone != x. 克隆后对象引用不同
      - x.clone.getClass == x.getClass. 克隆后类型相同
      - x.clone.equails(x). 克隆后equals相同
   
#### 结构模式 8种
 * 类结构与对象结构两种
 * 适配器
   + 类适配器与对象适配器
   + 将一个接口适配成另一个接口
 * 缺省适配器
 * 装饰
   + 透明的装饰原接口，是对原接口功能的增强
   + 删除与增加装饰对象时，程序都感觉不到。体现里氏代换原则
   + 如果只有一个装饰对象时，可以省略抽象装饰类，直接使用具体装饰类来装饰
   + 可以装饰类中增长一些新的方法。此时装饰类就成为半装饰类。如果新增方法越多离装饰模式越远
   + 与合成模式类结构图很像。可以在使用合成模式时，使用装饰来增强合成对象功能
 * 代理
   + 增加对原有对象的近制。由代理对象控制对原对象的引用
   + 代理类中关联的是被代理的具体对象引用，而不是被代理的抽象类引用
   + 远程代理
   + 虚拟代理
   + 克隆代理
   + 保护代理
   + cache代理
   + 防火墙代理
   + 同步化代理
   + 智能代理
 * 合成
   + 属于对象结构模式
   + 合成模式将对象组织到树结构中，可以用来描述整体与部分的关系
 * 享元
   + 单纯享元模式
   + 复合享元模式
   
 * 门面
   + 通过门面类访问子系统，每个子系统可以使用不同门面类。
   + 门面类相当于子系统的一个特殊客户端，子系统不知道门面类的存在。如果没有门面类也可以使用
   + 门面类作用是将子系统的行为提供给外界，如果一个子系统没有某个行为，则不通过修改门面类或继承门面类来提供这个新的行为。
   + 使用
     - 不同结构化层之间调用，可以使用门面类
     - 独立的子系统中，可以使用门面
    
 * 桥梁
   + 脱耦：就是将抽象化与实现化之间的强关联改为弱关联
   + 桥梁模式中的脱耦就是将软件系统中抽象化与实现化之间使用合成/聚合关系而不是继承关系
   + 桥梁模式主要是不同行为的处理。抽象角色与实现化角色是要完成相同的事情。只不过不使用继承关系而使用聚合关系
 
#### 行为模式 12种
 * 不变模式
   + 由于缺少改变自身状态的行为，因此它为是关于行为的模式
   + 不需要类图描述
   + 弱不变模式：子类是可以改变的对象
      - 没有方法可以修改对象状态
      - 所有属性都是私有
      - 如果引用一个可变对象，需要限制外界对这个可变对象访问，尽量不要在客户端初始化这个可变对象再传入。
      如果要客户端创建，则传入时复制一份
   + 强不变模式：子类与父类都是不可改变，属性，方法，类都是final的
 * 策略
   + 将每个算法封装到独立的类中
   + 角色
     - 调用者：创建策略并执行
     - 抽象策略
     - 具体策略
 * 模版方法
   + 是对继承最好的应用
 * 观察者
   + 缺点
      - 通知所有观察者费时
      - 注意死循环
   + 角色：
      - 抽象被观察者：聚合抽象观察者
      - 具体被观察者
      - 抽象观察者
      - 具体观察者  
    
 * 迭代子
   + 具体迭代器关联具体聚集对象
   + 具体聚集对象产出具体迭代器
   + 注意对内使用宽接口，对外使用窄接口
   + 角色 
     - 抽象迭代器
     - 具体迭代器：关联具体集合
     - 操作集合
     - 具体集合：聚合产品
     - 产品
 * 责任链
   + 一个请求的处理不确定由哪个接收者处理
   + 一个纯的责任链只能有两个行为中选择一个：一个是承担责任，一个是把责任推给下家
 * 命令
   + 一个请求的处理变得明确和确定
   + 定义：把一个请求或操作封装到一个对象中，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能
   + 请求方发出一个请求要求执行一个操作，接收方收到请求并执行操作。
     - 请求方不必知道接收方接口，不必知道请求怎么被接收，操作是否被执行，何时执行，怎么执行
   + 优点
     - 很容易加入到系统中
     - 允许接收请求方决定是否处理请求
     - 容易设计一个命令队列
     - 可以实现对请求的undo, redo
     - 容易记录日志
   + 角色
     - 调用者：依赖请求者，执行者。负责创建命令提供给请求者
     - 请求者：聚合命令
     - 执行者
     - 抽象命令
     - 具体命令：关联执行者
   
 * 备忘录
   + 备忘录对象用来存储一个对象内部状态的快照
   + 在不破坏封装的条件下，将一个对象的状态捕捉，并外部化存储起来。通常与命令和迭代器模式一起使用
   + 角色
     - 发起者：产生备忘录。依赖备忘录
     - 备忘录：宽接口用于恢复状态，窄接口用于提供给负责人
     - 负责人：负责保存备忘录，聚合备忘录
 * 状态
   + 允许一个对象在其内部状态改变的时候改变其行为
   + 多态原则是状态模式的核心
   + 角色
     - 环境对象：聚合抽象状态
     - 抽象状态：依赖环境对象
     - 具体状态
 * 访问者
 * 解释器
 * 调停者

### 优缺点

#### 抽象工厂
 * 缺点：如果要想自定义product时，需要连同工厂类一起自定义