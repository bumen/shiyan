### 面向对象建模与设计 

### 交互建模
 * 类建模描述系统中的对象及其关系，状态建模描述对象的生存期，交互建模描述对象如何交互。
   + 它们组成建模三角架
   
 * 交互模型描述对象要如果交互才能产生有用的结果。它是跨越许多对象的整体行为视图。
 而状态模型它独立检查每个对象。
 
 * 交互可以在不同的抽象层次上建模
    1. 较高层：用例
    3. 中高：顺序  
    2. 底：活动
    
### 用例模型
 * 描述系统如何与外部参与者交互

#### 参与者
 * 是系统的直接外部用户，直接与系统通信的一个对象或一组对象，但不是系统的一部。 
 * 参与者与系统直接相连，间接相连的对象不是参与者，不应该包含而作为系统模型的一部分。
   + 间接相连的对象只能通过参与者交互
 
#### 用例
 * 参与者与系统的各种交互都可以被量化成用例
 * 用例：是系统通过与参与者的交互可以提供的一段连贯的功能。
   + 每个用例会涉及一个或多个参与者以及系统本身
   
 * 用例把与部分系统功能相关的所有行为组合在一起
   + 普通主线行为：描述主要完成什么功能
   + 普通行为变化：描述主要完成功能的可能情况。如有些情况会发生有些不会
   + 异常条件：描述主要功能异常情况下的处理
   + 错误条件：描述主要功能错误情况下的处理
   + 请求取消：描述了取消息主要功能处理
   
#### 高级特性
 * 包含关系：将一个用例合并到另一个用例的行为序列中
   + 对当前用例一个更细一层的补充说明
   + 一般这个被包含的用例是可以被共享的，也可以单独存在，但是对于参与者是有意义的。
   + 被包含用例本来应该出现在更细一层抽象中，但为了更好的描述更高层的抽象，可以把它包含进来
   
 * 扩展关系
   + 给用例添加增量行为。对原有功能的扩展（原来不支持某个功能，现在某种条件触发后可以支持这种扩展功能）
   + 扩展用例会把自己加入到基用例中
   + 扩展用例不能作为行为序列单独出现，但基用例在没有此扩展时也必须是合法的
   + 大多数条件下，扩展关系有一个附加条件，只有附加条件为真时才触发扩展行为
   
 * 泛化
   + 与类的泛化很像，将一个更抽象的用例，用不同的具体子用例表示
   + 父用例表示通用的行为序列
   
 * 准则
   + 用例泛化：可以使用更抽象的用例加上特化的变体。但不要简单的使用泛化共享行为，应该使用包含
   + 用例包含：如果有多种场合使用的用例，可以使用包含
   + 用例扩展：可以在某些条件下执行扩展行为
   + 包含与扩展关系：
      - 包含关系意味着被包含行为是配置系统中一个必要的部分。
      - 扩展关系则暗示着没有增加行为的系统也会是有意义的（即原来用例再没有扩展也是有意义的）
      
 * 活动模型
   + 发送和接收信号
   + 泳道
   + 对象流
 
   
#### 构建用例模型指南
 * 首先确定系统的边界
   + 边界不清晰，识别用例或参与者是不可能的
 * 确保关注参与者。
   + 每个参与者都应该有单一的，一致的目的。如果有多种目的，则需要分别用单个参与者来捕获它们
 * 每个用例必须给用户提供价值
   + 用例应该表示成给用户提供有价值的完整事务，不应该定义过于狭窄。
      - 无价值的不完整的事物不能做为单为用例，应该为用例的一个部分
 * 关联用例和参与者
   + 每个用例至少要有一个参与者，每个参与者至少要参与一项用例
 * 记住用例是非形式化的
   + 不是形式化的，而是一种以用户为中心的角度来识别和组织系统功能的方法
 * 用例可以结构化
   + 可以共用
 
### 顺序模型
 * 显示一组对象随着时间变化所交换的消息。消息包括异步信号和过程调用。
 * 顺序模型详细描述用例的主题，有两种顺序模型，即场景和顺序图，顺序图具有更加结构化的形式
 
#### 场景
 * 指系统在某个特定的执行期内所发生的一系列事件。
   + 事件很重要
   + 可以包括系统中的所有事件，或者只包括与某些对象有关的事件或由这些对象产生的事件
 * 场景包含对象之间的消息与对象所执行的活动
   + 即什么事件产生了什么样的活动
 * 场景是通知描述性文例举出所有事件
   + 事件必须有参与者
   
#### 顺序图
 * 顺序图显示了
   + 交互的参与者
   + 交互的参与者之间的消息顺序
   + 系统为了执行全部或部分用例而与参与者的交互
   
 * 每个用例需要一张或多张顺序图来描述其行为，每张顺序图显示用例的一个特定的行为序列
 
 * 为用例内部的每种异常条件绘制一张顺序图
 
 * 顺序图里显示条件是有可能的，但通常为每个主要的控制流绘制一张顺序图会更清楚一些 
   + 如每个事件会有条件判断，不同的判断使用不同的顺序图
   
#### 顺序图模型的准则 
 * 有两种基本的顺序模型
   1. 场景：以文本形式记叙一系列事件
   2. 顺序图：更清楚的显示了参与者
 * 准则
   1. 至少为每个用例编写一种场景
      + 场景中的步骤应该是逻辑命令
   2. 把场景抽象成顺序图
   3. 划分复杂的交互。把大型交互划分成各个组成的任务，并为每一项任务绘制一张顺序图
   4. 为每种错误条件绘制一张顺序图
   
 * 专注于对象
 
### 活动模型
 * 提供更深入的细节，显示某次计算中处理步骤之间的流控。活动图可以显示数据流，也可以显示控制流。
 * 活动图显示了组成复杂过程的步骤序列。
   + 专注于操作
 * 活动图的目标
   + 显示复杂过程内部各个步骤以及它们之间的顺序约束（执行顺序）
   
#### 活动
 * 活动就是操作
 * 在活动图中，从一项活动到另一项活动的未标记箭头表示第一项活动必须在第二项活动开始之前完成
 
#### 分支
 * 如果一个活动有一个以上的后继，那么就需要使用分支。通过接入菱形实现
 
#### 并发活动

#### 活动模型准则
 * 不要误用活动图
   + 是用来详细描述用例和顺序模型
   + 不同于传统流程图
 * 让图保持平衡
   + 活动应该具有一致的细节层次。（在同一抽象层次上）
 * 注意分支和条件
   + 保存至少一个分支可以执行
 * 注意并发活动
 * 考虑使用可执行的活动图
   + 讲的不是很清楚
   
### 小结
 * 类模型、状态模型和交互模型都包含了相同的概念：数据，顺序，操作
   + 但每种模型只专注某个方面
   + 方法的实现会涉及到数据（目标对象，参数，变量），控制（构件顺序），交互（消息，调用和顺序）
