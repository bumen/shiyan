## redis
 
### redis 持久化

#### RDB持久化
 * 在只定时间间隔内生成数据集的时间点快照
 * rdb是一个非常紧凑的文件，它保存了某个时间点上的数据集。适合备份
 * rdb适合灾难恢复，也可以加密后将它将送别别的数据中心
 * rdb可以最大化redis的性能。通过启动子进程进行保存
 * rdb在恢复大数据集时的速度比AOF速度快
 * 缺点
   + 由于是基于时间点保存，所以不能保证在服务器故障时保存所有数据
   + 由于需要创建子进程保存，所以当数据量很大时，fork()会很耗时，如果CPU紧张的话，可能会造成服务器长时间停止处理客户端响应
 * 过程
   + 通过fork()，启动子进程
   + 将数据写入rdb文件
   + 写完成后，删除旧的rdb文件
 * 处理过期key
   + 写入时，发现过期不写入
   + 载入时，发现过期不载入
#### AOF持久化
 * 记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令还数据
 * 优点
   + 采用不同保存策略，保存在磁盘
   + 无fsnyc：由操作系统来处理，更快，也更不安全
   + 每秒一次fsnyc(默认策略)， 如果服务器故障停机，就算丢失也是1秒内的数据。足够快
   + 每次执行写入命令是fsnyc，很慢。每写入一个命令就保存到磁盘
   + fsnyc会在后台线程中运行，不会影响主线程处理请求
   + AOF文件只是追加记录，如果写入时磁盘满或写入时停面，aof工具可以修复写入不完整命令
   + 当AOF文件过大时，自动在后台进行AOF重写。这期间也会身旧的AOF文件追加命令，只有新的AOF写完成，才会删除旧的
   + AOF文件，格式简单，易读
 * 缺点
   + 当不小心flushall后，随后执行了AOF文件重写。则此时就没有记录
   + AOF数据体积大于rdb
   + AOF可能会产生一些bug
   + 当使用fsnyc时速度慢于rdb, 
   + 当服务器重启时，发现AOF文件出错，则拒绝载入这个AOF文件
 * 过程
   + 通过fork(), 启动子进程
   + 写入新的AOF文件
   + 对新写入的命令，父进程一边将它们累加到一个内存缓冲区，一边追加到旧的aof文件尾
   + 当新aof文件写入完成，父进程将缓冲区中的命令写到新文件
   + 删除旧的aof文件
 * 处理过期key
   + 持久化时，如果key过期，但没有删除，则写入
   + 持久化时，如果key过期，但删除了，则写入del
   + aof重写时，如果key过期，不会重写到aof
### redis 线程模型
 * 单线程，处理

### reids key过期策略
 * 三种过期策略：定时删除、惰性删除、定期删除
 * 定时删除
   + 在设置key的过期时间同时，为该key创建一个定时器，让定时器在key过期时，删除key
   + 优点：保证内存尽快释放
   + 缺点：如果过期key很多，会创建很多定时器，影响性能
 * 惰性删除
   + key过期后不删除，每次从数据库获取key的时候检查是否过期，若过期则删除返回null
   + 优点：对cpu占用时间少
   + 缺点：如果长时间不再获取key，则会造成大量过期key，为成垃圾数据。那么可能发生内存泄漏
   
 * 定期删除
   + 每隔一段时间执行一次删除
   + 优点：减少删除操作对cpu的时间占用，解决惰性删除的缺点
   + 缺点：如果key多会占用cpu时间
   + 通过hz配置，默认10， 即1秒扫描10次。100ms一次
   + 清理时遍历所有db
   + 从db中随机取20个key判断过期
   + 若有5个以上的key过期，则继续取20个再判断。否则查询下一个db
   + 在清理过期中，若达到了25%cpu时间，则退出
   
### redis内存使用
 * maxmemory属性设置最大内存。
   + 默认设置或是0，则64位无限制。32位限制3G
 * maxmemory-policy 当内存满后，删除key的策略
   + 默认谁也不删除，直接返回写操作失败
   + allkeys-lru：回收最近最少使用(LRU)的键，为新数据腾出空间
   + volatile-lru：回收最近最少使用(LRU)的键，但是只回收有设置过期的键，为新数据腾出空间。
   + allkeys-random：回收随机的键，为新数据腾出空间。
   + volatile-random：回收随机的键，但是只回收有设置过期的键，为新数据腾出空间。
   + volatile-ttl：回收有设置过期的键，尝试先回收离TTL最短时间的键，为新数据腾出空间

### redis 网络模型
 * 异步非阻塞多路复用i/o

### redis 集群
 * 水平扩展，高可用，主从复制
 * 
 
### redis 主从复制
 * redis使用异步复制，并每秒一次的频率向主服务器报告复制流的处理进度
   + 可能出现数据丢失情况
 * 支持一主多从
 * 复制不会阻塞主服务器
 * 复制也不会阻塞从服务器，
 * 可以从服务器实现读
 * 可以避免主服务器开启持久化，蛤需要从服务器开始持久化即可。
 
#### 复制过程
 * 从服务器向主服务器发送SYNC命令
 * 主服务器开始生成.rdb文件，这期间产生的写命令都保存到一个缓冲区。（如果同时接收到多台从服务器的SNYC命令，只会生成一个.rbd）
 * 生成.rdb文件后，把文件发送给从服务器
 * 从服务器发收.rdb文件后，加载入内存
 * 之后主服务器会把缓冲区中的命令发送给从服务器
 * 部分重同步
   + 当主从服务器断连时，主服务器会为发送的复制流创建一个内存缓冲区，和复制偏移量
   + 当重连接时，判断复制偏移量是否相同。
   + 如果相同主服务器只发送断线时缺失的那部分数据
   + 如果不同，则需要全复制
 
#### 只读从服务器
 * 从服务器支持只读模式， 该模式是从服务器的默认模式
 * 只读从服务器拒绝任何写命令
 * 
 
### redis 实战
#### redis 防止雪崩

#### redis 防止穿透

#### reids 架构