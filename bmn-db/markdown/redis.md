## redis
 
### 两种事件
 * 文件事件
   + 负责处理客户端命令请求
 * 时间事件
   + 负责执行定时运行的函数
 
### redis 持久化

### 分布式锁
#### 死锁问题
 * 获取锁的线程执行时间过长，进程被kill掉，或者其它异常崩溃。导致无法释放锁，就会造成死锁。
 * 通过对加锁做时效性检测
 
#### setNx, getSet, get, del实现分布式锁
 * 有两个方法 lock(), unlock()
 * lock
   + setNx name, value (value是当前系统的时间戳)
   + 1次get得到的v1, if v1 超时， 则与 getSet 返回的v2 比较。如果相同则可以获取锁
   + 会产生时间戳覆盖问题
   + nil问题。当get返回 v1= nil时
    当线程获取锁，并处理完后，del锁，del前，另一线程setnx失败，走get v1=nil操作（此时del成功），
   （1）：走循环走setnx
   （2）：走超时逻辑
   
 * unlock 
 * 锁覆盖会导致什么问题呢？
   + 当客户端的锁过期时间被覆盖，会造成锁不具有标识性，会造成客户端无法释放锁（客户端只能释放明确自己持有的锁）。
   + 因为A持有的锁，可能value是由B,C...调用getSet设置的。

#### 分布式锁产生的安全问题
 * 当GC造成的STW时间过长时，导致锁过期。造成不安全
 * 如果锁的过程中，有io操作，但io阻塞时间过长，造成的锁过期
 * 修改时间

#### RDB持久化
 * 在只定时间间隔内生成数据集的时间点快照
 * rdb是一个非常紧凑的文件，它保存了某个时间点上的数据集。适合备份
   + 经过压缩，文件小
 * rdb适合灾难恢复，也可以加密后将它将送别别的数据中心
 * rdb可以最大化redis的性能。通过启动子进程进行保存
 * rdb在恢复大数据集时的速度比AOF速度快
   + rdb存的是内存数据
   + aof存的是命令
 * 缺点
   + 由于是基于时间点保存，所以不能保证在服务器故障时保存所有数据
   + 由于需要创建子进程保存，所以当数据量很大时，fork()会很耗时，如果CPU紧张的话，可能会造成服务器长时间停止处理客户端响应
 * 过程
   + 通过fork()，启动子进程，fork时会阻塞父进程，fork完成后，不再阻塞父进程。
   + 子进程根据父进程内存数据快照，将数据写入临时文件rdb文件
   + 写完成后，删除旧的rdb文件
   + 因为是一次性写磁盘，不是增量写入。所以当key过多时，写操作比较多，必然引起大量磁盘io操作，影响性能
 * 处理过期key
   + 写入时，发现过期不写入
   + 载入时，发现过期不载入
 * 配置
   + 可以配置是否开启压缩，LZF压缩，压缩后很少
   + 可以配置是否开启CRC检验，开启后影响性能
 * 主动备份
   + save，通过主线程备份，会阻塞主进程写入
   + bgsave, 通过fork子进程备份
     - 会检查是否已经有在执行rdb/aof持久化任务，如果有则返回
#### AOF持久化
 * 记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令还数据
 * 优点
   + 首写先入到aof缓冲区，然后采用不同保存策略，保存在磁盘 
   + 无fsnyc：由操作系统来处理，更快，也更不安全
     - redis关闭
     - AOF功能关闭
     - aof_buffer满，或执行过保存
   + 每秒一次fsnyc(默认策略)， 如果服务器故障停机，就算丢失也是1秒内的数据。足够快
     - 由后台子线程调用，不会阻塞主进程
   + 每次执行写入命令是fsnyc，很慢。每写入一个命令就保存到磁盘
     - 由主进程执行，然而主进程又是单线程写入
   + AOF文件只是追加记录，如果写入时磁盘满或写入时停面，aof工具可以修复写入不完整命令
   + 当AOF文件过大时，自动在后台进行AOF重写。这期间也会身旧的AOF文件追加命令，只有新的AOF写完成，才会删除旧的
   + AOF文件，格式简单，易读
 * 缺点
   + 当不小心flushall后，随后执行了AOF文件重写。则此时就没有记录
   + AOF数据体积大于rdb
   + AOF可能会产生一些bug
   + 当使用fsnyc时速度慢于rdb, 
   + 当服务器重启时，发现AOF文件出错，则拒绝载入这个AOF文件
 * 过程
   + 通过fork(), 启动子进程，是父进程数据的一个快照，通过写快照数到临时文件
   + 写入新的AOF文件
   + 对新写入的命令，父进程一边将接收到的请求累加到一个内存缓冲区，一边追加到旧的aof文件尾
     - 防止本次写入失败
   + 当新aof文件写入完成，父进程将缓冲区中的命令写到新文件
   + 删除旧的aof文件
 * 处理过期key
   + 持久化时，如果key过期，但没有删除，则写入
   + 持久化时，如果key过期，但删除了，则写入del
   + aof重写时，如果key过期，不会重写到aof
 * AOF重写
   + 手动，自动触发
   + 自动触发
     - 当文件小于64m时不进行重写
     - 当文件比上次AOF文件大一倍是进行重写
   + 过程
     - 如果有重写，返回，如果有bgsave则，执行完bgsave后重写
     - redis fork子进程重写
     - aof重写时，不影响原来aof持久化过程
     - aof重写时，主进程收到命令会写入aof重写缓冲区
     - aof重写子进程拿到fork时AOF文件进行重写
     - 将拿到的AOF文件重写到临时文件
     - 重写完成后，将aof缓冲区命令写入临时文件，并使用新文件替换
   + 重写aof文件时，每次写硬盘的数据量由配置决定，不能太大，否则会导致硬盘阻塞
 * 主动备份
   + bgrewriteaof， 通过定期重写
### redis 线程模型
 * 单线程，处理

### reids key过期策略
 * 三种过期策略：定时删除、惰性删除、定期删除
 * 定时删除
   + 在设置key的过期时间同时，为该key创建一个定时器，让定时器在key过期时，删除key
   + 优点：保证内存尽快释放
   + 缺点：如果过期key很多，会创建很多定时器，影响性能
 * 惰性删除
   + key过期后不删除，每次从数据库获取key的时候检查是否过期，若过期则删除返回null
   + 优点：对cpu占用时间少
   + 缺点：如果长时间不再获取key，则会造成大量过期key，为成垃圾数据。那么可能发生内存泄漏
   
 * 定期删除
   + 每隔一段时间执行一次删除
   + 优点：减少删除操作对cpu的时间占用，解决惰性删除的缺点
   + 缺点：如果key多会占用cpu时间
   + 通过hz配置，默认10， 即1秒扫描10次。100ms一次
   + 清理时遍历所有db
   + 从db中随机取20个key判断过期
   + 若有5个以上的key过期，则继续取20个再判断。否则查询下一个db
   + 在清理过期中，若达到了25%cpu时间，则退出
   
### redis内存淘汰机制
 * maxmemory属性设置最大内存。
   + 默认设置或是0，则64位无限制。32位限制3G
 * maxmemory-policy 当内存满后，删除key的策略
   + 默认谁也不删除，直接返回写操作失败
   + allkeys-lru：回收最近最少使用(LRU)的键，为新数据腾出空间
   + volatile-lru：回收最近最少使用(LRU)的键，但是只回收有设置过期的键，为新数据腾出空间。
   + allkeys-random：回收随机的键，为新数据腾出空间。
   + volatile-random：回收随机的键，但是只回收有设置过期的键，为新数据腾出空间。
   + volatile-ttl：回收有设置过期的键，尝试先回收离TTL最短时间的键，为新数据腾出空间

### redis 网络模型
 * 异步非阻塞多路复用i/o

### redis 集群
 * 水平扩展，高可用，主从复制
 * 
 
### redis 主从复制
 * redis使用异步复制，并每秒一次的频率向主服务器报告复制流的处理进度
   + 可能出现数据丢失情况
 * 支持一主多从
 * 复制不会阻塞主服务器
 * 复制也不会阻塞从服务器，
 * 可以从服务器实现读
 * 可以避免主服务器开启持久化，只需要从服务器开始持久化即可。
 
#### 复制过程
 * 从服务器向主服务器发送SYNC命令
 * 主服务器开始生成.rdb文件，这期间产生的写命令都保存到一个缓冲区。（如果同时接收到多台从服务器的SNYC命令，只会生成一个.rbd）
 * 生成.rdb文件后，把文件发送给从服务器
 * 从服务器发收.rdb文件后，加载入内存
 * 之后主服务器会把缓冲区中的命令发送给从服务器
 * 部分重同步
   + 当主从服务器断连时，主服务器会为发送的复制流创建一个内存缓冲区，和复制偏移量
   + 当重连接时，判断复制偏移量是否相同。
   + 如果相同主服务器只发送断线时缺失的那部分数据
   + 如果不同，则需要全复制
 
#### 只读从服务器
 * 从服务器支持只读模式， 该模式是从服务器的默认模式
 * 只读从服务器拒绝任何写命令
 * 
 
### redis 实战

#### redis压缩

#### redis 防止雪崩
 * 缓存同一时间大面积失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉
 * 保证redis集群的高可用性
 * 使用Hystrix 限流
 * 解决
   + 给缓存的失效时间，加上一个随机值，避免集体失效。
   + 使用互斥锁，但是该方案吞吐量明显下降
   + 双缓存，a缓存失效时间20分钟，b缓存不失效
      - a有数据直接返回。
      - a没有数据返回b数据，同时异步更新a,b
 

#### redis 防止穿透
 * 一般是黑客故意去请求缓存中不存的数据，导致所有的请求落到数据库上，造成数据库短时间内承受大量请求而崩掉。
 * 采用布隆过滤器，将所有可能存在的数据hash到一个足够大的bitmap中，一定不存在的数据会被这个bitmap拦截掉。
 * 如果发现数据不存在。则也进行缓存，加过期时间。下次请求就落到缓冲上。
 * 如果有大并发的项目，流量有几百万左右，则需要考虑
 * 解决
   + 利用互斥锁，缓存失效时，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。
   + 采用异步更新策略，无论key是否有值都直接返回，为value维护一个缓存失效时间，缓存如果过期，异步线程去读数据库更新缓存。需要做缓存预热
   + 提供一个能迅速判断请求是否有效的拦截机制。比如布隆过滤，内部维护一系列合法有效key.如果判断不合法，直接返回。
 
#### 缓存与数据库双写一致性问题
 * 如果有强一致性要求的数据，不能放缓存
 * 只能保证最终一致性

#### 缓存的并发竞争问题
 * 如果key操作，不要求顺序。使用分布式锁
 * 如果key操作，要求顺序。使用队列，或为key设置时间

#### reids 架构