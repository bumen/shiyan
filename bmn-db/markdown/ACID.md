## ACID原则
 * 事物的特性
 * 关系数据库，遵循ACID定理。
 
### A(Atomicity)
 * 原子性
 
### C（Consistency）
 * 一致性
   + 数据库中a+b=10，不管a,b怎么变最终累加都是10
   
### 隔离性Isolation
 * 是对并发事务的处理
 * 有4种处理方式
 
 * 更新丢失
   + 如果多个线程操作，基于同一个查询结构对表中的记录进行修改，
   那么后修改的记录将会覆盖前面修改的记录，前面的修改就丢失掉了，
   这就叫做更新丢失
   
   + 第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。   
   |时间|     取款事务A      |       转账事务B      |  
   |---|------------------ |--------------------|
   |T1 | 开始事务            |                    |
   |T2 |                   | 开始事务             |
   |T3 | 查询账户余额为1000元 |                    |
   |T4 |                   | 查询账户余额为1000元  |
   |T5 |                   | 汇入100修改为1100元  |
   |T6 |                   |       提交事务       |
   |T7 | 取出100余额为900元  |                    |
   |T8 |    撤销事务         |                    |
   |T9 |余额为1000元(更新丢失)|                    |
   
   + 第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。 
   |时间|     取款事务A      |       转账事务B      |  
   |---|------------------ |--------------------|
   |T1 |                   |      开始事务        |
   |T2 |  开始事务           |                    |
   |T3 |                   | 查询账户余额为1000元  |
   |T4 | 查询账户余额为1000元 |                    |
   |T5 |                   | 汇入100修改为1100元  |
   |T6 |                   |       提交事务       |
   |T7 | 取出100余额为900元  |                    |
   |T8 |    提交事务         |                    |
   |T9 |余额为900元(更新丢失) |                    |   
   + 解决
     - 对行加锁，只允许并发一个更新事务
 

#### Read Uncommitted
 * 一个事务可以读取另一个事务未提交的操作
   + 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，
   但允许其他事务读此行数据
   + 该隔离级别可以通过“排他写锁”实现
 * 避免更新丢失
 * 可能产生脏读
 * 脏读
   + A事务读到B事务未提交的数据，而且B事务还回滚了，此时A事务拿到是脏数据
   ，此A更新此数据后就不正确了。
 * 解决
   + 使用Read committed
   + 对行加锁，只允许并发一个更新事务
 
#### Read committed
 * 一个事务可以读取另一个事务已经提交的操作
   + 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行
 * 避免脏读
   + 如果在第一个事务提交前，任何其他事务不可读取其修改过的值，则可以避免该问题
 * 可能出现重复读取相同一条记录出现数据不一致问题
 * 不可重复读
   + 事务A查一条记录发现有100元，事务B修改了这条记录为50元。事务A再取到
   这条记录时，发现只有50元。造成同一个事务A两个读取数据不一致
   > 避免修改一条记录同时，允许查询事务执行
 * 不可重复读影响 
   + A去取钱发现有100元，B此时花了50元。当A取的时候发现取不100元
   
 * 解决
   + 使用Repeatable read

### Repeatable read
 * 可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，
 另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，
 即使第二个事务对数据进行修改，第一个事务两次读到的的数据是一样的。
 这样就发生了在一个事务内两次读到的数据是一样的，因此称为是可重复读。
   + 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。
   这样避免了不可重复读取和脏读
   + 这可以通过“共享读锁”和“排他写锁”实现。
 * 避免重复读出现的不一致问题
 * 可能出现幻读。
 * 幻读
   + 当某个事务在读取某个范围内记录时，另外一个事务又在该范围内插入了新记录
   ，当之前事务再读取时记录发现数据行数发生变化
   > 关于Inster和Delete操作时对Select的影响 
 * 幻读影响
   + A查询自己消费记录为10条，然后打印后发现有11条，好像是幻觉。
   
 * 解决使用Serializable

### serializable
 * 串行执行
 * 避免幻读
   + 如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题
 
### 持久性Durability
 * 事务提交，数据必须保存上
 
### 总结
 * 隔离级别越高，越能保证数据的完整性和一致性，
 但是对并发性能的影响也越大。对于多数应用程序，
 可以优先考虑把数据库系统的隔离级别设为Read Committed。
 它能够避免脏读取，而且具有较好的并发性能。
 尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，
 在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。
 大多数数据库的默认级别就是Read committed，
 比如Sql Server , Oracle。
 MySQL的默认隔离级别就是Repeatable read。
 
 * 虽然数据库的隔离级别可以解决大多数问题，
 但是灵活度较差，为此又提出了悲观锁和乐观锁的概念。
