## mysql数据库

### 数据库原理
<<<<<<< HEAD
#### 字段类型
 * tinyint 1Byte
 * smallint 2Byte
 * mediumint 3Byte
 * int 4Byte
 * bigint 8Byte
 
=======
 * sql 子查询
   + 相关子查询：放在select后，外部select每扫描一行，子查询就执行一次。效率低
   + 非相关子查询：放在select后，子查询执行一次
   
>>>>>>> bed71101b938486d5e462aaa674cd8cc87ee6755

#### MyISAM与Innodb区别
 * 使用count(*)
   + MyISAM会记录表数据量，速度快
   + Innodb会查询会表，速度慢
 * 使用带where条件的count(*)
   + MyISAM与Innodb性能差不多，如果有索引查在索引后扫描所有记录
 * 全文索引
   + MyISAM带全文索引
   + Innodb5.6之前不带，之后带
   + 但数据量大，高并发场景不要使用自带全文索引，会导致小量请求占用大量数据库资源
   + 应该使用索引外置：ES, Lucence
 * 事物
   + MyISAM不支持事物
   + Innodb支持物事。它提供了commit, rollback，崩溃修复能力。但也非常大消耗性能，会影响吞吐量
   + 建议在强一致性要求才使用
 * 外键
   + MyISAM不支持外键
   + Innodb支持外键
   + 不管哪种引擎，在大并发下都应该使用外键。建议由应用程序保证完整性
 * 锁
   + MyISAM只支持表锁
      - select+ insert的业务应用MyISAM，因为在文件尾部顺序增加记录速度很快
      - 但一般是混合读写，只要数据量大和并发量大一律使用Innodb
   + Innodb支持行锁 
 * 索引结构不同
   + MyISAM：索引与数据分开存储
   + Innodb：主键索引与数据存储在一块
 
### 数据库设计

### 数据库调优
#### SQL优化
 * 索引相关
   + 负向条件查询不能使用索引：!=, <>, not in, not, !>, !<
   + 前导模糊查询不能使用索引
        - where desc like "%xxx"
        - where desc like "xxx%", 可以索引
   + 数据区分度不大的字段不宜使用索引
        - 每次过滤的数据很少
        - 经验，通过滤80%数据时就可以使用索引
   + 禁止在where 条件的属性上进行计算，使用函数或表达式。不能命中索引
        - where avg(age) > 50
   + 如果业务大部分是单条查询，使用hash索引性能更好
        - B+tree索引时间复杂度是O(lg(n))
        - Hash索引的时间复杂度是O(1)
   + 单索引字段数不允许超过5过，多了起不到有效过滤作用
   + 禁止在更新频繁字段建立索引
        - 更新会变量B+tree
   + 建立复合索引，把区分度高的字段放在前面
        
 * Null列，查询有潜在大坑
   + 单列索引不存null值，复合索引不存全为null的值，如果列为null可能查不到数据
   + 把字段设置not null, 并提供默认值
   + null类型字段，mysql内部需要进行特殊处理，增加处理记录复杂性
   + null值需要更多存储空间
   
 * 复合索引最左前缀，并不是值SQL语句的where顺序要和复合索引一致
   + （name, pwd) 建复合索引
   + where name=? and pwd = ?与where pwd=? and name=?都可以命中索引
   + where name=? 满足复合索引最左前缀，也能命中
   + where pwd =? 不能命中索引
 * 使用ENUM而不是字符串
 * 如果明确知道只有一条结果返回，limit 1 能够提高效率
   + 通过明确告诉数据库，让它主动停止游标移动
 * 把计算放到业务层而不是数据库层，除了节省数据cpu，还可以使用查询缓存
   + 多次调用相同sql，可以使用查询缓存
 * 强制类型转换会全表扫描
 * union all肯定是能命中索引
   + select * from o where s = 0 union all select * from o where s = 1
   + 直接告诉mysql怎么做，cpu耗时最少
   + union all 代替union, union会有去重开销
 * 简单的in能够命中索引
   + select * from o where s in(0,1)
   + 让mysql思考，查询优化耗费cpu比union all多，但可以忽略不计
 * 对于or, 新版的Mysql能命中索引
   + 让Mysql思考，查询优化耗费cpu比in多，
   + 不建议程序频繁用or
 * 尽量不使用Join
 * 打散批量更新
 
#### 数据库调优
 * 使用性能分析工具
   + show profile
   + mysqlsla
   + mysqldumpslow
   + explain
   + show slow log
   + show processlist
   + show query_response_time(percona)
   
   
### 主从复制降低主从同步延时
 * 由于从库单线程重放relaylog导致高并发大数据量时，延时过长
 * 优化
   + 多线程并行重放：相同库使用相同线程重放，不同库使用不同线程重放
   不足：对于单库多表，还是串行执行
   mysql5.6支持
   + 基于GTID的并行复制：可以满足单库多表重放
   mysql5.7支持
   

### 主从数据库一致性
#### 为什么会出现不一致
 * 主从同步有时延，任何数据冗余，必将引发一致性问题
 
#### 解决
 * 可以允许一段时间的不一致
 * 强制读主，读写都在主库（保证高可用）通过加缓存提升系统读性能
 * 选择性读主
   + 把要写的key记录到redis
   + 读的时候如果redis有记录则去读主，如果redis没有则去读从

### 关系型数据库
 * ACID原则
 * 范式
   
#### 范式 Normal Form
 * 满足最低要求叫第一范式，再进一步满足一些要求为第二范式。
 各范式呈次规范，越高的范式数据库冗余越小。通常用到的只是前三范式
 * 范式可以避免数据冗余，减少数据库空间，减轻维护数据完整性麻烦
 * 按照范式的规范设计出来表，等级越高的范式设计出来的表越多
 
 * 第一范式（1NF）
   + 强调列的原子性。即无重复列 
 * 第二范式（2NF）
   1.表必须有主键
   2.没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
 * 第三范式（3NF）
   + 任何非主属性不依赖其它非主属性（在2NF基础上消除传递依赖）
   + 即一张表非主属性不依赖于其它表非主属性(一张表非主属性只依赖其它表主属性即可-不是传递关系的依赖)，避免冗余
 * 巴斯-科德范式（BCNF）
 * 第四范式（4NF）
 * 第五范式（5NF）
 
### 反范式
 * 允许适当的数据冗余，用这个冗余去实现取操作数据时间的缩短。
 减少查询时的表关联，是空间换时间。
 