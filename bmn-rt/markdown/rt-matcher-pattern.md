## java正则表达式

### 正则表达式引擎
 * DFA自动机（Deterministic Final Automata 确定型有穷自动机）
   + 时间复杂度是线性的，更加稳定，但是功能有限
 * NFA自动机（Non Deterministic Finite Automaton 不确定型有穷自动机）
   + 时间复杂度不稳定，有时候好，有时候不好，好不好取决于你的正则表达式
   + NFA功能更加强大
  
### NFA自动机
 * 三种模式：
   + 贪婪模式，会发生回溯
   + 懒惰模式，会发生回溯
   + 独占模式，尽可能多地匹配，但是不回溯
   
 * 匹配过程
   + 读取正则表达式的一个一个字符，然后拿去和目标字符串匹配，匹配成功就换正则表达式的下一个字符。否则继续和目标字符串的下一个字符比较
   
#### NFA自动机回溯
 * 当正则表达式如：reg = ab{1,3}c, 与字符串abbc匹配
 * 先匹配a, 再匹配b
 * 由于b{1,3}, 再有NFA的贪婪特性，此时会一直匹配b, 直到匹配到c时返回，此时会就发生回溯
 * 指针由于上次匹配到达了c，此时再回到c匹配，
 
### 匹配中文标点符号
 * 说明
 > Unicode 编码并不只是为某个字符简单定义了一个编码，而且还将其进行了归类  
 > /pP 其中的小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。  
 > 大写 P 表示 Unicode 字符集七个字符属性之一：标点字符。  
 > 其他六个是  
 > L：字母；
 > M：标记符号（一般不会单独出现）；
 > Z：分隔符（比如空格、换行等）；
 > S：符号（比如数学符号、货币符号等）；
 > N：数字（比如阿拉伯数字、罗马数字等）；
 > C：其他字符
 > 上面这七个是属性，七个属性下还有若干个子属性，用于更进一步地进行细分。
 > Java 中用于 Unicode 的正则表达式数据都是由 Unicode 组织提供的。
 > Unicode 正则表达式标准（可以找到所有的子属性）
 > http://www.unicode.org/reports/tr18/
 > 各 Unicode 字符属性的定义，可以用一看看某个字符具有什么属性。
 
 * 测试
   ``` 
      String string="测试<>《》！*(^)$%~!@#$…&%￥—+=、。，；‘’“”：·`文本";
      System.out.println(string.replaceAll("\\pP|\\pS", ""));
   ```

### 元字符 
 * \w 
   + 字母，数字，下划线，汉字
 * \s
   + 匹配任意空白字符（即ASCII控制字符）
 * \d
   + 数字
 * \b 
   + 匹配单词的开始或结束
 * . 
   + 除换行符以外的任意字符
 * ^ $

### 重复限定符
 * ?, *, +, {n}, {n,}, {n,m}

### 分组
 * ()

### 转义
 * \\

### 条件或
 * |

### 区间
 * [1-9]
 * [134]

### 零宽度断言
 * (?=pattern)
   + 正向先行断言
 * (?<=pattern)
   + 正向后行断言
 * (!=pattern)
   + 反向先行断言
 * (!<=pattern)
   + 反向后行断言
   
### 捕获与非捕获
 * (expr) | (?<name>pattern)
   + 捕获
 * (?:pattern)
   + 非捕获组
   
### 反向引用
 * \k
 * \'name'
 
### 贪婪与非贪婪
 * 默认为贪婪
   + 会使匹配串发生回溯
 * 非贪婪：在重复限制符后加?
   + ??
   + *?
   + +?
   + {n,}?
   + {n,m}?
   + 会使模式串发生回溯
   
### 独占模式 
 * 尽可能多的匹配，但不回溯
   + ?+
   + *+
   + ++
   + {n,}+
   + {n,m}+
 
### 反义
 * 是元字符的大写
 * \W, \S, \D, \B [^x], [^abc]
 
 
#### 字符串匹配过程事例
 * 模式串  
   + `p1 = (.*([上下听]/N.title)\s*)+(.*/N.title)\s*(第\s)?(?<number>[0-9零一二两三四五六七八九十百千万]+)?.*`
   + `p2 = .*(([上下听]/N.title)\s*)+(.*/N.title)\s*(第\s)?(?<number>[0-9零一二两三四五六七八九十百千万]+)?.*`
   
 * 匹配串
   + `str = asd 听/N.title 下/N.title 写/N.title google other`
 * p1与p2匹配过程具体使用RegexBuddy debug查看
 
 * 贪婪使用情况
   + 一般用于后缀匹配时，可以快速匹配
   + 如：
   ``` 
      // 匹配后面的f。因为.*是匹配所有。然后从后向前回溯去匹配f
      p = ".*f"; s = "abcdefg"
      
   ```
 * 非贪婪使用情况
   + 一般用于前缀匹配时，可以快速匹配
   + 如：
   ``` 
      //匹配前面的b。因为.*?是匹配所有，但是非贪婪匹配一个成功后，就会回溯拿一下个字符串字符与b比较，
      p = ".*?b"; s = "abcdefg"
   ```
   
 