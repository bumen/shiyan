## 锁

### 可重入死锁
    ```
    public class Lock{
      private boolean isLocked = false;
      public synchronized void lock()
        throws InterruptedException{
        while(isLocked){
          wait();
        }
        isLocked = true;
      }
    
      public synchronized void unlock(){
        isLocked = false;
        notify();
      }
    }
    ```
 + 如果一个线程在两次调用lock()间没有调用unlock()方法，那么第二次调用lock()就会被阻塞，就出现了重入锁死。
 
 
 
###  读写锁
 * 获取写锁，有读锁，没有写锁的时，不能获得写锁
 * 获取写锁，有读锁，有写锁时，可重入写锁
 * 获取读锁，有写锁，如果可降级到读锁失败，则等待
 * 读锁不能升级到写锁，但写锁可以降级到读锁。
 * 读写锁使用一个状态来表示，高16位用于读锁，低16位用于写锁
   + 一个状态可以解决读写锁之前存在竞争
   + 读锁位
   + 写锁位
 * 总结读写锁
   + 要么读，要么写。
   + 读写同时获取，只能是一个线程。通过写锁降级获取读锁，通过写锁重入获取写锁。
   + 其它线程再获取写锁或读锁时，只能通过公平与非公平方式获取。
   + 在公平与非公平方式获取读锁时，不满足条件，则只有重入读锁可以获取。
   + 非公平下，读锁不会抢占将要获取写锁的线程。
   
 * 使用
   + 有写锁时插入读锁
     - 只能降级实现，否则读线程加入队列
   + 有写锁时插入写锁
     - 只能重入实现，否则写线程加入队列
     
   + 有读锁时插入写锁
     - 只能重入到写锁
   + 有读锁时插入读锁
     
#### 公平
 * read,write should block 
   + 判断锁等待队列是否为空
 * 获取读锁
   1. 判断如果写锁不能降级到读锁则直接加到等待队列
   2. 等待队列没有其它人，则获得读锁
   3. 如果2步存在竞争则循环获取读锁
   4. 循环判断1步
   5. 如果是重入读锁（即已经获取了读锁）, 则可以继续获取读锁
   6. 如果不是重入读锁，则加入到等待队列
 * 获取写锁
   1. 判断重入写锁，成功则获取
   
 
#### 非公平
 * read, write should block
   + read should block 判断等待队列头结点是否为写等待
   + write should block 返回false
 * 获取读锁
   1. 判断如果写锁不能降级到读锁，则直接加到等待队列
   2. 等待队列头结点是获取写锁，则直接加到等待队列，如果是头结点是等待读锁则可以获取锁
   3. 如果2步存在竞争则循环获取读锁
   4. 循环判断1步
   5. 如果是重入读锁（即已经获取了读锁）, 则可以继续获取读锁
   6. 如果不是重入读锁，则加入到等待队列
 * 获取写锁
    1. 判断重入写锁，成功则获取