## java.util包

### Collection
 
#### 扩容
 * ArrayList
   + new ArrayList<>(); 容量为0，elementData指向固定static final对象，必然重建无用对象
   + new ArrayList<>(capacity); 容量为capacity, 当capacity = 0时，elementData指向固定static final对象，避免重复创建无用对象
   + add方法扩容：如果使用new ArrayList<>()方式创建的，则初始容量为10，再次扩容为当前容量的1/2
     10(5), 15(7), 21(10), 31(15), 46(23), 69, 92, 138
     1(1), 2(1), 3(1), 4(2), 6(3), 9(4), 13(6), 19(9), 28(14), 42(21), 63
     5(2), 7(3), 10(5)
     8(4), 12(6), 18(9)
     11(5), 21(10), 
     13(6), 19(9)
     14(6), 21(10),
     16(8), 24(12), 36(18), 54(27), 81(40), 121
     17(8), 25(12), 37(18), 55(27), 82(41) ,
   + addAll方法扩容：如果使用new ArrayList<>()方式创建的，则用默认容量10与当前添加的容量比较，选择大的做为扩容容量
     则初始容量为10或为添加的容量，再次扩容则为当前容量的1/2，如果扩容1/2 > 添加的长度，则进行扩容，否则就使用添加的长度
   + 当能预估容量小于10时，最好创建时指定容量
   + 当能预估容量大于10时，可以使用默认
   
 * HashMap
   + 当key为null时，统一放到0位置，所以只能放一个key为null的
   + 默认容量是16， 负载因子0.75f
   + new HashMap<>(); 不初始化容量，不会申请任何容量
   + 新创建的HashMap(); 
     1. 设置了初始容量，使用容量2的n次方, 同时threshold是容量*负载因子
      如果设置的容量小于16，则每次扩容后判断之前容量是否大于16，只大于16时，threshold为原来一倍，否则=容量*负载因子
     2. 未设置初始容量，使用默认容量，同时threshold是容量*负载因子
   + 对已有HashMap扩容，
     1. 如果容量已达到最大，则不允许扩容
     2. 否则，扩大原来一倍，同时如果之前容量大于默认容量时，则threshold也扩大一倍，否则=容量*负载因子
   + 创建新的数组，重新hash元素
   
 *
### LinkedHashMap
 * 通过构造函数AccessOrder控制是需要记录顺序访问
 * 记录顺序访问
   + 插入时把元素添加到队列尾，同时判断是否需要删除最旧元素（即头元素）
   + 获取时把元素重新添加到队列尾
   
### Hashtable
 * 是线程安全容器，
 * key, value都不能为null
 * new Hashtable(), 时直接创建数组，不是在添加元素时才创建
 * new Hashtable(), 默认容量是11， 初始负载因 子是0.75f 
   
   
### java8 ConcurrentHashMap
 * 第一次put操作成功后都返回null，其它再put相同key时，返回旧值
 * key, value都不允许为null
 * 如果key放到数组上时，通过cas原子操作更新
 * 如果key hash相同，要通过synchronized链表头节点，然后插入链表尾
 * 当链表长度超过8时，把链表转红黑树
 * hashCode
   + 通过key.hashCode()方法产生，并做高16位与低16位异或
   + 然后与（n-1）& hash