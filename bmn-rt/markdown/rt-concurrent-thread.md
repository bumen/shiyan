## 多线程

### 活跃度
 * 死锁 
   + 多个线程永久阻塞，相互等待对方释放资源
 * 饥饿
   + 一个线程不能正常访问共享资源并且不能正常执行。通常是共享资源被其它“贪心”线程长期占有。
   + 一个不可爱的线程被一直等待进入同步块
   + 一个不可爱的线程一直在wait池中。每次随机唤醒的都是别人
   
 * 活锁-嵌套管程锁死
   + 由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败...
   + 如任务失败，重新把任务加到队列再执行，再失败再执行...
   + 当A线程获取this锁， 同时获取OtherObject锁，此时调用OtherObject.wait()等待B线程唤醒，只释放了OtherObject锁，没有释放this锁
   + 当B线程获取this锁， 通知A时，由于A没有释放this锁，把B无法通知A。
   + 此时A与B一直等待对方
   + 
   
 * 避免死锁
   + 加锁顺序
   + 加锁时限
   + 死锁检测
   + 使用非阻塞算法
   
   
 * 避免饥饿
   + 使用公平锁
   
### 竞太条件
 * 多个线程同时修改共享资源，资源可能有A线程的状态或B线程的状态
 
### 优点
 * 充分利用CPU资源
 * 程序设计某些情况下更简单
 * 程序响应更快
 * 提高程序响应速度
 
### 缺点
 * 设计更复杂
 * 增加上下文切换开销
 * 增加资源消耗（每个线程都会占用一些内存）
 
### 并发与并行
 * 并发是指同时处理不同的任务
 * 并行是指同时处理相同的任务
 
### IO密集型与CPU密集型
 * 通过业务类型只能大概区别是IO密集型还是CPU密集型
 * 要想确定业务具体的类型，除非业务类型简单并且明确。所以很难确定一个通用的业务处理线程数
 * 所以在确定线程数时，就需要根据压力测试，性能分析来确定线程数量。
 
### 并发编程模型
 * 并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。
 * 不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。
 
#### 并发模型与分布式系统之间的相似性
 * 并发模型是线程之间相互通信，分布式系统是进程之间相互通信
 * 分布式中还需要处理网络失效、远程主机或进程宕掉等方面的挑战。
 * 并发系统也可能遇到类似的问题，如CPU失效，一块网卡失效，或一个磁盘损坏。
 * 由于并发模型与分布式系统架构类似，因此它们通常可以相借鉴思想。
   + 如工作线程分配作业模型与分布式系统中的负载均衡系统比较相似
   + 对于日志记录、失效转移、幂等性错误处理技术上也具有相似性
 * 幂等性：一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。
 
 
#### 并行工作者模型
 * 委派者(Delegator)将传入的作业会被分配到不同的工作者上
 * 优点：
   + 很容易了解，只需要添加更多的工作者来提高系统的并行度
   + 如：网络爬虫是一个IO密集型工作，因为在等待数据下载的过程中CPU将会空闲大量时间。
   
 * 缺点
   + 访问共享数据会很复杂
   + 有些共享状态是在像作业队列这样的通信机制下，但有一些共享状态是业务数据，数据缓存，数据库连接池等。
   + 要避免内存一致性问题
   + 当访问阻塞数据时，会导致一定程度出现串行化。
   + 非阻塞并发算法不好实现
   + 无状态的工作者，需要每次使用都去重读。会导致速度变慢
   + 任务顺序不确定，A,B任务分配到不同线程。可能A快于B完成，也可能是B快于A完成。
   
#### 流水线模式-无共享并行模型（反应器系统，事件驱动系统）
 * 每个工作者只负责作业中的部分工作，当完成时交给下一个工作者。不会与其它工作者共享状态。
 
#### 函数式并行模型
 * forkandjoin
 
### ThreadLocal
 * 一个ThreadLocal对象代表一个线程本地变量
 * 存储在Thread对象属性ThreadLocalMap中
 * ThreadLocalMap中以ThreadLocal对象的弱引用做为key
#### 内存泄漏
 * 栈中的强引用为Thread, 与ThreadLocal
 * 如果栈中存在Thread强引用，但不存在ThreadLocal强引用，则gc会回收ThreadLocalMap中弱引用key
 * 此时key为null, 但是value还存在强引用。由于key取不到，而value一真存在，所以出现泄漏。
 
#### 解决内存泄漏
 * 再次调用get或set方法是会删除key为null的entry
 * 使用完变量，主动remove删除
 * jdk建议使用private static定义ThreadLocal对象，让ThreadLocal对象生命周期变长，
 * 由于一真存在ThreadLocal强引用所以key不为null 
 
   