## java多线程

### 基本的线程同步方式
 * volatile
 * final 构造属性
 * happen-before 规则
 * 原子变量
   + CPU在一条指令执行过程中不会进程线程调度和上下文切换，但两条指令的执行间隙，可能发生线程切换。
   + value++如果是一条指令来完成。就不存在多线程访问时出现不一致问题

### Object wait notify notifyall
 * 处于某个对象所关联的等待集合中的线程可能被意外唤醒，是由底层操作系统和虚拟机内部实现所产生的非正常行为。
 * 这个意外的唤醒无法避免，需要开发人员来处理。
   ```
        synchronized(obj) {
           while(条件不满足) {
               obj.wait();
           }
        }
   ```
 
### Thread类
 * 线程状态：Thread.State
   + 只表示虚拟机中线程的状态，并不表示对应操作系统上的线程状态。
   + Blocked： 等待一个监视器对象上的锁
   + WAITTING: wait(0)
   + TIME_WAITTING: wait(time)
   + TERMINATED: 线程已停止
   
### 线程之间通信
 * volatile
 
 * 线程中断
   + 线程中断是线程间的一种通信方式。
   + 通过interrupt发出中断请求，根据线程不同状态，中断一个线程会产生不同的效果。
   + 中断一个线程会在线程对象上设置一个中断标记
   + isInterrupted判断是有中断请求发生
   + 当A向B发出中断请求时，线程B会在方便的时候处理这个中断请求，这不是必须的。
   + wait, join, sleep 会抛出中断异常
   + 当收InterruptedException发生时，当前线程的中断标记会被清空，相当于中断异常的处理逻辑处理了。
 * wait 中断
   + 线程需要在重新获取到监视器对象上的锁之后才会抛出中断异常，并执行中断异常处理逻辑
   
 * interrupted不但可以判断当前线程是否被中断，还会清除中断标记
 * 当等待集合中一个线程被notify唤醒，同时被唤醒这个线程又被中断。
   + 运行结果取决于两者实际发生的顺序，由虚拟机实现来确定。
   + 如果被唤醒的一个线程又被中断，则等待集合的另外一个线程必须被唤醒。